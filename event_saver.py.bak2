# -*- coding: utf-8 -*-
# event_saver.py - v4.5.1 - CORRE√á√ÉO: Janelas vazias e race conditions
"""
EventSaver v4.5.1 - Sistema de salvamento de eventos de trading

üîπ CORRE√á√ïES v4.5.1:
  ‚úÖ FIX: Janelas vazias corrigidas (separador agora √© processado no flush)
  ‚úÖ FIX: Race condition entre separador e evento resolvida
  ‚úÖ FIX: File lock adicionado ao separador visual

üîπ v4.5.0:
  ‚úÖ Clock Sync integrado (compensa drift autom√°tico)
  ‚úÖ Timestamps sempre sincronizados com servidor Binance
  ‚úÖ Logs informativos de sincroniza√ß√£o

üîπ v4.4.1:
  ‚úÖ File locking multiplataforma (Windows/Linux/macOS)
  ‚úÖ Import condicional de fcntl/msvcrt
  
üîπ v4.4.0:
  ‚úÖ Memory leak corrigido
  ‚úÖ Timezone NY com detec√ß√£o de DST (EDT/EST)
  ‚úÖ Buffer com limite m√°ximo
  ‚úÖ Valida√ß√£o robusta de epoch_ms
"""

import json
from pathlib import Path
import platform
import logging
import threading
import time
import atexit
from datetime import datetime, timedelta, timezone
from typing import Dict, Any, Optional, List, Union, Tuple
import re

# ===== FILE LOCKING MULTIPLATAFORMA =====
LOCK_METHOD = None
fcntl_module = None
msvcrt_module = None

try:
    import fcntl as fcntl_module
    LOCK_METHOD = 'fcntl'
except ImportError:
    if platform.system() == 'Windows':
        try:
            import msvcrt as msvcrt_module
            LOCK_METHOD = 'msvcrt'
        except ImportError:
            LOCK_METHOD = None
    else:
        LOCK_METHOD = None

# ===== CLOCK SYNC =====
try:
    from clock_sync import get_clock_sync
    HAS_CLOCK_SYNC = True
    _clock_sync_instance = None
except ImportError:
    HAS_CLOCK_SYNC = False
    _clock_sync_instance = None

# ===== CONFIGURA√á√ïES =====
MAX_BUFFER_SIZE = 10000  # Limite m√°ximo de eventos no buffer
MAX_JSON_FILE_SIZE = 50 * 1024 * 1024  # 50MB m√°ximo
CLEANUP_INTERVAL = 300  # Limpa cache a cada 5 min
SEEN_BLOCK_TTL = 3600  # Mant√©m seen_in_block por 1h

# ===== REGEX PR√â-COMPILADOS =====
NUMBER_PATTERN = re.compile(r'^[\d\.\-]+$')
PAREN_PATTERN = re.compile(r'\((.*?)\)')

# ===== TRATAMENTO ROBUSTO DE TIMEZONES =====
TIMEZONE_AVAILABLE = False
UTC_TZ = None
NY_TZ = None
SP_TZ = None

try:
    from zoneinfo import ZoneInfo
    UTC_TZ = ZoneInfo("UTC")
    NY_TZ = ZoneInfo("America/New_York")
    SP_TZ = ZoneInfo("America/Sao_Paulo")
    TIMEZONE_AVAILABLE = True
except ImportError:
    try:
        import pytz
        UTC_TZ = pytz.UTC
        NY_TZ = pytz.timezone("America/New_York")
        SP_TZ = pytz.timezone("America/Sao_Paulo")
        TIMEZONE_AVAILABLE = True
    except ImportError:
        logging.warning("Nenhuma biblioteca de timezone dispon√≠vel. Usando offsets din√¢micos.")
        UTC_TZ = timezone.utc
        
        class DynamicNYTZ:
            """Timezone de NY com detec√ß√£o de DST."""
            def __init__(self):
                self.utc = timezone.utc
                
            def _is_dst(self, dt: datetime) -> bool:
                """Verifica se est√° em hor√°rio de ver√£o (DST)."""
                year = dt.year
                
                # Encontra segundo domingo de mar√ßo
                march = datetime(year, 3, 1)
                days_to_sunday = (6 - march.weekday()) % 7
                first_sunday = march + timedelta(days=days_to_sunday)
                second_sunday = first_sunday + timedelta(days=7)
                dst_start = second_sunday.replace(hour=2, minute=0, second=0, microsecond=0, tzinfo=self.utc)
                
                # Encontra primeiro domingo de novembro
                november = datetime(year, 11, 1)
                days_to_sunday = (6 - november.weekday()) % 7
                first_sunday = november + timedelta(days=days_to_sunday)
                dst_end = first_sunday.replace(hour=2, minute=0, second=0, microsecond=0, tzinfo=self.utc)
                
                # Compara
                if dt.tzinfo is None:
                    dt = dt.replace(tzinfo=self.utc)
                
                return dst_start <= dt < dst_end
            
            def get_offset(self, dt: datetime) -> timezone:
                """Retorna timezone com offset correto."""
                if self._is_dst(dt):
                    return timezone(timedelta(hours=-4))  # EDT
                else:
                    return timezone(timedelta(hours=-5))  # EST
        
        NY_TZ = DynamicNYTZ()
        SP_TZ = timezone(timedelta(hours=-3))

# ===== TRATAMENTO DE NUMPY =====
try:
    import numpy as np
    HAS_NUMPY = True
except ImportError:
    HAS_NUMPY = False

# ===== IMPORT SEGURO DO TIME_MANAGER =====
try:
    from time_manager import TimeManager
except ImportError:
    class TimeManager:
        def now_iso(self, tz=None):
            if tz:
                return datetime.now(tz).isoformat()
            return datetime.now().isoformat()

# ===== IMPORT SEGURO DE FORMAT_UTILS =====
try:
    from format_utils import (
        format_price,
        format_quantity,
        format_percent,
        format_large_number,
        format_delta,
        format_time_seconds,
        format_scientific
    )
    HAS_FORMAT_UTILS = True
except ImportError:
    HAS_FORMAT_UTILS = False
    
    def format_price(value):
        if value is None:
            return "null"
        try:
            if abs(value) >= 1000:
                return f"${value:,.2f}"
            else:
                return f"${value:.4f}"
        except:
            return str(value)

    def format_quantity(value):
        if value is None:
            return "null"
        try:
            if abs(value) >= 1_000_000:
                return f"{value/1_000_000:.2f}M"
            elif abs(value) >= 1_000:
                return f"{value/1_000:.2f}K"
            else:
                return f"{value:.3f}"
        except:
            return str(value)

    def format_percent(value):
        if value is None:
            return "null"
        try:
            return f"{value:.2f}%"
        except:
            return str(value)

    def format_large_number(value):
        if value is None:
            return "null"
        try:
            if abs(value) >= 1_000_000_000:
                return f"{value/1_000_000_000:.2f}B"
            elif abs(value) >= 1_000_000:
                return f"{value/1_000_000:.2f}M"
            elif abs(value) >= 1_000:
                return f"{value/1_000:.2f}K"
            else:
                return f"{value:,.2f}"
        except:
            return str(value)

    def format_delta(value):
        if value is None:
            return "null"
        try:
            sign = "+" if value > 0 else ""
            return f"{sign}{value:.3f}"
        except:
            return str(value)

    def format_time_seconds(value):
        if value is None:
            return "null"
        try:
            return f"{value:.1f}s"
        except:
            return str(value)

    def format_scientific(value):
        if value is None:
            return "null"
        try:
            if abs(value) < 0.0001:
                return f"{value:.2e}"
            else:
                return f"{value:.6f}"
        except:
            return str(value)

# ===== DIRET√ìRIO DE DADOS =====
DATA_DIR = Path("dados")
DATA_DIR.mkdir(exist_ok=True)


# ===== FUN√á√ïES HELPER DE FILE LOCKING =====
def acquire_file_lock(file_obj, blocking=True, timeout=5.0):
    """
    Adquire lock de arquivo multiplataforma.
    
    Args:
        file_obj: Objeto de arquivo aberto
        blocking: Se True, aguarda at√© conseguir lock
        timeout: Tempo m√°ximo de espera (apenas para blocking=True)
    
    Returns:
        bool: True se conseguiu lock, False caso contr√°rio
    """
    if LOCK_METHOD is None:
        return True  # Sem locking dispon√≠vel
    
    try:
        if LOCK_METHOD == 'fcntl':
            if blocking:
                # Tenta com timeout
                start_time = time.time()
                while True:
                    try:
                        fcntl_module.flock(file_obj.fileno(), fcntl_module.LOCK_EX | fcntl_module.LOCK_NB)
                        return True
                    except IOError:
                        if time.time() - start_time > timeout:
                            return False
                        time.sleep(0.1)
            else:
                fcntl_module.flock(file_obj.fileno(), fcntl_module.LOCK_EX | fcntl_module.LOCK_NB)
                return True
                
        elif LOCK_METHOD == 'msvcrt':
            if blocking:
                start_time = time.time()
                while True:
                    try:
                        msvcrt_module.locking(file_obj.fileno(), msvcrt_module.LK_NBLCK, 1)
                        return True
                    except IOError:
                        if time.time() - start_time > timeout:
                            return False
                        time.sleep(0.1)
            else:
                msvcrt_module.locking(file_obj.fileno(), msvcrt_module.LK_NBLCK, 1)
                return True
                
    except Exception as e:
        logging.debug(f"Erro ao adquirir lock: {e}")
        return False
    
    return True


def release_file_lock(file_obj):
    """Libera lock de arquivo multiplataforma."""
    if LOCK_METHOD is None:
        return
    
    try:
        if LOCK_METHOD == 'fcntl':
            fcntl_module.flock(file_obj.fileno(), fcntl_module.LOCK_UN)
        elif LOCK_METHOD == 'msvcrt':
            msvcrt_module.locking(file_obj.fileno(), msvcrt_module.LK_UNLCK, 1)
    except Exception as e:
        logging.debug(f"Erro ao liberar lock: {e}")


class EventSaver:
    """
    Classe respons√°vel por salvar e formatar eventos de trading.
    
    ‚úÖ v4.5.1: Corre√ß√£o de janelas vazias e race conditions
    ‚úÖ v4.5.0: Clock Sync integrado
    ‚úÖ v4.4.1: File locking multiplataforma (Windows/Linux/macOS)
    ‚úÖ v4.4.0: Corre√ß√µes cr√≠ticas de memory leak, timezone, race conditions e performance
    """
    
    def __init__(self, sound_alert: bool = True):
        self.sound_alert = sound_alert
        self.snapshot_file = DATA_DIR / "eventos-fluxo.json"
        self.history_file = DATA_DIR / "eventos_fluxo.jsonl"
        self.visual_log_file = DATA_DIR / "eventos_visuais.log"
        self.last_window_id = None
        self.time_manager = TimeManager()
        self._window_counter = 0
        
        # _seen_in_block com timestamp para limpeza
        self._seen_in_block: Dict[Tuple, float] = {}
        self._last_cleanup_time = time.time()
        
        # Buffer de escrita + thread de flush
        self._write_buffer: List[Dict] = []
        self._buffer_lock = threading.Lock()
        self._flush_interval = 5
        self._stop_event = threading.Event()
        self._flush_thread = threading.Thread(target=self._flush_loop, daemon=True)
        self._flush_thread.start()
        
        # Thread de cleanup
        self._cleanup_thread = threading.Thread(target=self._cleanup_loop, daemon=True)
        self._cleanup_thread.start()
        
        # Logger
        self.logger = logging.getLogger(__name__)
        
        # Stats
        self._buffer_overflow_count = 0
        self._lock_timeout_count = 0
        
        # ‚úÖ NOVO: Inicializa Clock Sync
        if HAS_CLOCK_SYNC:
            try:
                global _clock_sync_instance
                if _clock_sync_instance is None:
                    self.logger.info("üïê Inicializando Clock Sync...")
                    _clock_sync_instance = get_clock_sync()
                    
                    # Aguarda primeira sincroniza√ß√£o
                    time.sleep(0.5)
                    
                    if _clock_sync_instance.is_synced():
                        offset = _clock_sync_instance.get_offset_seconds()
                        if abs(offset) > 0.5:
                            self.logger.info(
                                f"‚úÖ Clock Sync ativo | "
                                f"Offset: {offset:+.3f}s | "
                                f"Compensa√ß√£o autom√°tica habilitada"
                            )
                        else:
                            self.logger.info(
                                f"‚úÖ Clock Sync ativo | "
                                f"Rel√≥gio bem sincronizado (offset: {offset:+.3f}s)"
                            )
                    else:
                        self.logger.warning("‚ö†Ô∏è Clock Sync: sincroniza√ß√£o inicial pendente")
                        
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è Clock Sync n√£o dispon√≠vel: {e}")
                _clock_sync_instance = None
        else:
            self.logger.info("‚ÑπÔ∏è Clock Sync n√£o dispon√≠vel (usando timestamps locais)")
        
        # Encerra limpo no exit
        atexit.register(self.stop)
        
        # Verifica√ß√£o inicial
        self._debug_timezone_check()
        
        lock_status = "HABILITADO" if LOCK_METHOD else "DESABILITADO"
        lock_type = f"({LOCK_METHOD})" if LOCK_METHOD else ""
        
        self.logger.info(
            "‚úÖ EventSaver v4.5.1 inicializado | "
            "Buffer max: %d | Cleanup: %ds | File locking: %s %s",
            MAX_BUFFER_SIZE,
            CLEANUP_INTERVAL,
            lock_status,
            lock_type
        )

    def _debug_timezone_check(self):
        """Verifica se os timezones est√£o funcionando corretamente."""
        try:
            now_utc = datetime.now(UTC_TZ)
            if TIMEZONE_AVAILABLE:
                now_ny = self._convert_timezone(now_utc, NY_TZ)
                now_sp = self._convert_timezone(now_utc, SP_TZ)
                self.logger.info("üïê Verifica√ß√£o de Timezone:")
                self.logger.info(f"   UTC: {now_utc.strftime('%Y-%m-%d %H:%M:%S')} UTC")
                self.logger.info(f"   NY:  {now_ny.strftime('%Y-%m-%d %H:%M:%S')} (EST/EDT)")
                self.logger.info(f"   SP:  {now_sp.strftime('%Y-%m-%d %H:%M:%S')} (BRT)")
                
                if hasattr(now_ny, 'utcoffset') and now_ny.utcoffset():
                    utc_offset_ny = now_ny.utcoffset().total_seconds() / 3600
                    self.logger.info(f"   Offset NY vs UTC: {utc_offset_ny:.1f} horas")
                if hasattr(now_sp, 'utcoffset') and now_sp.utcoffset():
                    utc_offset_sp = now_sp.utcoffset().total_seconds() / 3600
                    self.logger.info(f"   Offset SP vs UTC: {utc_offset_sp:.1f} horas")
            else:
                if hasattr(NY_TZ, 'get_offset'):
                    offset_tz = NY_TZ.get_offset(now_utc)
                    dst_status = "EDT (-4h)" if offset_tz.utcoffset(None).total_seconds() == -14400 else "EST (-5h)"
                    self.logger.info(f"   NY usando offset din√¢mico: {dst_status}")
                else:
                    self.logger.warning("‚ö†Ô∏è Usando offsets fixos (NY: -5h, SP: -3h)")
        except Exception as e:
            self.logger.error(f"Erro ao verificar timezones: {e}")

    def _convert_timezone(self, dt: datetime, target_tz) -> datetime:
        """Converte datetime para timezone alvo de forma segura."""
        try:
            # Suporte para DynamicNYTZ
            if hasattr(target_tz, 'get_offset'):
                offset_tz = target_tz.get_offset(dt)
                if dt.tzinfo is not None:
                    return dt.astimezone(offset_tz)
                else:
                    dt_utc = dt.replace(tzinfo=UTC_TZ)
                    return dt_utc.astimezone(offset_tz)
            
            # Se j√° tem timezone
            if dt.tzinfo is not None:
                if hasattr(target_tz, 'normalize'):
                    return target_tz.normalize(dt.astimezone(target_tz))
                else:
                    return dt.astimezone(target_tz)
            else:
                if UTC_TZ == timezone.utc:
                    dt_utc = dt.replace(tzinfo=UTC_TZ)
                    return dt_utc.astimezone(target_tz)
                else:
                    if hasattr(UTC_TZ, 'localize'):
                        dt_utc = UTC_TZ.localize(dt)
                    else:
                        dt_utc = dt.replace(tzinfo=UTC_TZ)
                    if hasattr(target_tz, 'normalize'):
                        return target_tz.normalize(dt_utc.astimezone(target_tz))
                    else:
                        return dt_utc.astimezone(target_tz)
        except Exception as e:
            self.logger.debug(f"Erro na convers√£o de timezone: {e}")
            return dt

    @staticmethod
    def _parse_iso8601(ts: str) -> datetime:
        """Parseia timestamp ISO-8601 com suporte a 'Z' (UTC) e offset."""
        if not ts:
            raise ValueError("Timestamp vazio")
        try:
            if ts.endswith("Z"):
                ts = ts[:-1] + "+00:00"
            dt = datetime.fromisoformat(ts)
            if dt.tzinfo is None:
                dt = dt.replace(tzinfo=UTC_TZ)
            return dt
        except Exception as e:
            try:
                base = ts.split(".")[0]
                if "+" in base:
                    base, offset = base.split("+")
                    ts_clean = f"{base}+{offset}"
                elif "-" in base and base.count("-") > 2:
                    parts = base.split("-")
                    base = "-".join(parts[:3])
                    offset = "-".join(parts[3:])
                    ts_clean = f"{base}-{offset}"
                else:
                    ts_clean = base + "+00:00"
                return datetime.fromisoformat(ts_clean)
            except Exception:
                try:
                    dt_str = ts.replace("Z", "").replace("T", " ").split(".")[0]
                    dt = datetime.strptime(dt_str, "%Y-%m-%d %H:%M:%S")
                    return dt.replace(tzinfo=UTC_TZ)
                except:
                    raise ValueError(f"N√£o foi poss√≠vel parsear timestamp: {ts}") from e

    def _cleanup_loop(self):
        """Thread que limpa recursos periodicamente."""
        while not self._stop_event.wait(CLEANUP_INTERVAL):
            try:
                self._cleanup_seen_in_block()
            except Exception as e:
                self.logger.error(f"Erro no cleanup: {e}")
    
    def _cleanup_seen_in_block(self):
        """Limpa entradas antigas de _seen_in_block."""
        try:
            now = time.time()
            cutoff = now - SEEN_BLOCK_TTL
            
            cleaned = {
                k: v for k, v in self._seen_in_block.items()
                if v > cutoff
            }
            
            removed = len(self._seen_in_block) - len(cleaned)
            
            if removed > 0:
                self._seen_in_block = cleaned
                self.logger.debug(
                    f"üßπ Cleanup: {removed} entradas antigas removidas de _seen_in_block "
                    f"({len(cleaned)} restantes)"
                )
                
            self._last_cleanup_time = now
            
        except Exception as e:
            self.logger.error(f"Erro ao limpar _seen_in_block: {e}")

    def stop(self):
        """Para threads e realiza flush final."""
        if not self._stop_event.is_set():
            self._stop_event.set()
            
            # Para threads
            try:
                if self._flush_thread.is_alive():
                    self._flush_thread.join(timeout=2.0)
                if self._cleanup_thread.is_alive():
                    self._cleanup_thread.join(timeout=1.0)
            except Exception as e:
                self.logger.error(f"Erro ao parar threads: {e}")
            
            # Flush final
            with self._buffer_lock:
                buffer_copy = self._write_buffer.copy()
                self._write_buffer.clear()
            
            if buffer_copy:
                self._flush_buffer(buffer_copy)
                self.logger.info(f"Flush final: {len(buffer_copy)} eventos")

    def _is_nan_or_inf(self, value) -> bool:
        """Verifica se um valor √© NaN ou Inf."""
        if value is None:
            return False
        if HAS_NUMPY:
            try:
                return np.isnan(value) or np.isinf(value)
            except (TypeError, ValueError):
                return False
        else:
            try:
                if isinstance(value, float):
                    return value != value or value in (float('inf'), float('-inf'))
                return False
            except:
                return False

    def _clean_numeric_value(
        self, 
        value: Any, 
        field_type: str = "generic"
    ) -> Optional[Union[int, float]]:
        """Limpa e arredonda um valor num√©rico."""
        if value is None or value == '':
            return None
        if isinstance(value, str):
            if value.lower() in ['n/a', 'none', 'null', 'nan', 'inf', '-inf']:
                return None
            value = value.replace(',', '')
        try:
            num_value = float(value)
            if self._is_nan_or_inf(num_value):
                return None
            
            precision_map = {
                "price": 4,
                "quantity": 3,
                "percent": 2,
                "delta": 3,
                "scientific": 8,
                "generic": 4
            }
            precision = precision_map.get(field_type, 4)
            rounded_value = round(num_value, precision)
            
            if rounded_value == int(rounded_value) and field_type != "scientific":
                return int(rounded_value)
            return rounded_value
        except (ValueError, TypeError, OverflowError):
            return None

    def _clean_event_data(self, event: Dict) -> Dict:
        """Limpa recursivamente todos os campos num√©ricos do evento."""
        if not isinstance(event, dict):
            return event
            
        try:
            cleaned = {}
            
            field_types = {
                'price': {'preco', 'price', 'close', 'open', 'high', 'low', 'poc', 'val', 'vah', 
                         'level', 'bid_price', 'ask_price', 'wall_price', 'anchor'},
                'quantity': {'volume', 'quantity', 'size', 'count', 'trades', 'interest'},
                'delta': {'delta', 'flow', 'imbalance', 'net'},
                'percent': {'pct', 'percent', 'ratio', 'prob', 'rate'},
                'scientific': {'volatility', 'returns', 'slope', 'momentum', 'correlation', 'gradient'},
                'timestamp': {'epoch_ms', 'timestamp_ms', 'window_ms', 'time_ms', '_ms', '_ts'}
            }

            def get_field_type(key: str) -> str:
                key_lower = key.lower()
                if any(ts in key_lower for ts in field_types['timestamp']):
                    return 'timestamp'
                for field_type, keywords in field_types.items():
                    if field_type != 'timestamp':
                        if any(kw in key_lower for kw in keywords):
                            return field_type
                return 'generic'

            for key, value in event.items():
                field_type = get_field_type(key)
                
                if field_type == 'timestamp':
                    cleaned[key] = value
                elif isinstance(value, (int, float)):
                    clean_value = self._clean_numeric_value(value, field_type)
                    if clean_value is not None:
                        cleaned[key] = clean_value
                elif isinstance(value, str) and value.replace('.', '').replace('-', '').replace('+', '').replace(',', '').isdigit():
                    clean_value = self._clean_numeric_value(value, field_type)
                    if clean_value is not None:
                        cleaned[key] = clean_value
                elif isinstance(value, dict):
                    cleaned_dict = self._clean_event_data(value)
                    if cleaned_dict:
                        cleaned[key] = cleaned_dict
                elif isinstance(value, list):
                    cleaned_list = []
                    for item in value:
                        if isinstance(item, dict):
                            clean_item = self._clean_event_data(item)
                            if clean_item:
                                cleaned_list.append(clean_item)
                        elif isinstance(item, (int, float)):
                            clean_value = self._clean_numeric_value(item, field_type)
                            if clean_value is not None:
                                cleaned_list.append(clean_value)
                        elif item is not None:
                            cleaned_list.append(item)
                    
                    if key.lower() in ['hvns', 'lvns', 'historical_volumes'] and len(cleaned_list) > 10:
                        cleaned[key] = cleaned_list
                    elif cleaned_list:
                        cleaned[key] = cleaned_list
                elif value is not None:
                    cleaned[key] = value

            return cleaned
            
        except Exception as e:
            self.logger.error(f"Erro ao limpar dados: {e}")
            return event

    def _flush_loop(self):
        """Thread que periodicamente esvazia o buffer."""
        while not self._stop_event.wait(self._flush_interval):
            with self._buffer_lock:
                if not self._write_buffer:
                    continue
                buffer_copy = self._write_buffer.copy()
                self._write_buffer.clear()
            if buffer_copy:
                self._flush_buffer(buffer_copy)

    def _flush_buffer(self, events: List[Dict]):
        """Escreve eventos em lote nos arquivos."""
        for event in events:
            try:
                # ‚úÖ CORRE√á√ÉO 1: Adiciona separador ANTES de processar evento
                if event.get("_needs_separator"):
                    self._add_visual_separator(event)
                    event.pop("_needs_separator", None)
                
                cleaned_event = self._clean_event_data(event)
                if cleaned_event:
                    self._save_to_json(cleaned_event)
                    self._save_to_jsonl(cleaned_event)
                    self._add_visual_log_entry(cleaned_event)
            except Exception as e:
                self.logger.error(f"Erro ao processar evento no flush: {e}")

    def _save_to_json(self, event: Dict):
        """Salva evento em arquivo JSON com retry e file locking."""
        max_retries = 3
        retry_delay = 0.5
        
        for attempt in range(max_retries):
            lock_file = None
            lock_acquired = False
            
            try:
                # Valida√ß√£o de tamanho antes de ler
                if self.snapshot_file.exists():
                    file_size = self.snapshot_file.stat().st_size
                    if file_size > MAX_JSON_FILE_SIZE:
                        self.logger.error(
                            f"‚ùå Arquivo JSON muito grande ({file_size/1024/1024:.1f}MB), "
                            f"recriando..."
                        )
                        backup = self.snapshot_file.with_suffix('.backup')
                        self.snapshot_file.rename(backup)
                        events = []
                    else:
                        # File locking
                        lock_file_path = self.snapshot_file.with_suffix('.lock')
                        
                        try:
                            lock_file = open(lock_file_path, 'w')
                            lock_acquired = acquire_file_lock(lock_file, blocking=True, timeout=3.0)
                            
                            if not lock_acquired:
                                self.logger.warning(f"Timeout ao adquirir lock (tentativa {attempt+1})")
                                self._lock_timeout_count += 1
                                if lock_file:
                                    lock_file.close()
                                    lock_file = None
                                raise IOError("Lock timeout")
                                
                        except Exception as e:
                            if lock_file:
                                lock_file.close()
                                lock_file = None
                            raise
                        
                        # L√™ eventos existentes
                        try:
                            with open(self.snapshot_file, "r", encoding="utf-8") as f:
                                content = f.read().strip()
                                if content:
                                    events = json.loads(content)
                                else:
                                    events = []
                        except (json.JSONDecodeError, IOError) as e:
                            self.logger.warning(f"JSON corrompido, recriando: {e}")
                            events = []
                else:
                    events = []

                # Adiciona novo evento
                events.append(event)
                
                # Limita tamanho
                max_events = 1000
                if len(events) > max_events:
                    events = events[-max_events:]

                # Salva atomicamente
                temp_file = self.snapshot_file.with_suffix('.tmp')
                with open(temp_file, "w", encoding="utf-8") as f:
                    json.dump(events, f, indent=2, ensure_ascii=False, default=str)
                
                temp_file.replace(self.snapshot_file)
                
                # Libera lock
                if lock_file and lock_acquired:
                    release_file_lock(lock_file)
                    lock_file.close()
                    try:
                        lock_file_path.unlink(missing_ok=True)
                    except:
                        pass
                    
                return  # Sucesso
                
            except Exception as e:
                self.logger.error(f"Erro ao salvar JSON (tentativa {attempt+1}): {e}")
                
                if lock_file:
                    try:
                        if lock_acquired:
                            release_file_lock(lock_file)
                        lock_file.close()
                        lock_file_path = self.snapshot_file.with_suffix('.lock')
                        lock_file_path.unlink(missing_ok=True)
                    except:
                        pass
                
                if attempt < max_retries - 1:
                    time.sleep(retry_delay * (2 ** attempt))
                else:
                    self._save_fallback(event, "json")

    def _save_to_jsonl(self, event: Dict):
        """Salva evento em arquivo JSONL com retry."""
        max_retries = 3
        retry_delay = 0.5
        
        for attempt in range(max_retries):
            try:
                with open(self.history_file, "a", encoding="utf-8") as f:
                    json_line = json.dumps(event, ensure_ascii=False, default=str)
                    f.write(json_line + "\n")
                    f.flush()
                return
            except Exception as e:
                self.logger.error(f"Erro ao salvar JSONL (tentativa {attempt+1}): {e}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay * (2 ** attempt))
                else:
                    self._save_fallback(event, "jsonl")

    def _save_fallback(self, event: Dict, format_type: str):
        """Salva em diret√≥rio de fallback."""
        try:
            fallback_dir = Path("./fallback_events")
            fallback_dir.mkdir(exist_ok=True)
            
            if format_type == "json":
                fallback_file = fallback_dir / f"eventos_{datetime.now().strftime('%Y%m%d')}.json"
                events = []
                if fallback_file.exists():
                    try:
                        with open(fallback_file, "r", encoding="utf-8") as f:
                            events = json.load(f)
                    except:
                        events = []
                events.append(event)
                with open(fallback_file, "w", encoding="utf-8") as f:
                    json.dump(events, f, indent=2, ensure_ascii=False, default=str)
            else:
                fallback_file = fallback_dir / f"eventos_{datetime.now().strftime('%Y%m%d')}.jsonl"
                with open(fallback_file, "a", encoding="utf-8") as f:
                    f.write(json.dumps(event, ensure_ascii=False, default=str) + "\n")
                    
            self.logger.warning(f"‚ö†Ô∏è Evento salvo em fallback: {fallback_file}")
        except Exception as e:
            self.logger.critical(f"üíÄ FALHA em fallback: {e}")

    def save_event(self, event: Dict):
        """
        API p√∫blica para salvar um evento.
        
        ‚úÖ v4.5.1: Corre√ß√£o de race condition com separador
        ‚úÖ v4.5.0: Usa Clock Sync para timestamps precisos
        """
        if not isinstance(event, dict):
            self.logger.error("Evento inv√°lido: n√£o √© um dicion√°rio")
            return

        try:
            # ‚úÖ Valida√ß√£o com Clock Sync
            epoch_ms = event.get("epoch_ms")
            timestamp = event.get("timestamp")
            dt = None
            
            # Usa Clock Sync se dispon√≠vel
            if HAS_CLOCK_SYNC and _clock_sync_instance and _clock_sync_instance.is_synced():
                if not epoch_ms:
                    # Cria timestamp do servidor (compensado com drift)
                    epoch_ms = _clock_sync_instance.get_server_time_ms()
                    event["epoch_ms"] = epoch_ms
                    self.logger.debug(f"Timestamp criado com Clock Sync: {epoch_ms}")
                
                # Converte epoch_ms para datetime
                if isinstance(epoch_ms, (int, float, str)):
                    try:
                        epoch_ms_int = int(epoch_ms)
                        if 946684800000 <= epoch_ms_int <= 4102444800000:
                            dt = datetime.fromtimestamp(epoch_ms_int / 1000, tz=UTC_TZ)
                    except:
                        pass
            
            # Fallback: valida√ß√£o sem Clock Sync
            if not dt:
                if epoch_ms:
                    if isinstance(epoch_ms, (int, float)):
                        try:
                            epoch_ms_int = int(epoch_ms)
                            # Valida range razo√°vel (ano 2000 - 2100)
                            if 946684800000 <= epoch_ms_int <= 4102444800000:
                                dt = datetime.fromtimestamp(epoch_ms_int / 1000, tz=UTC_TZ)
                            else:
                                self.logger.warning(f"epoch_ms fora do range: {epoch_ms_int}")
                        except (ValueError, TypeError, OSError) as e:
                            self.logger.error(f"epoch_ms inv√°lido {epoch_ms}: {e}")
                    elif isinstance(epoch_ms, str):
                        try:
                            epoch_ms_int = int(epoch_ms)
                            if 946684800000 <= epoch_ms_int <= 4102444800000:
                                dt = datetime.fromtimestamp(epoch_ms_int / 1000, tz=UTC_TZ)
                        except:
                            self.logger.error(f"epoch_ms string inv√°lido: {epoch_ms}")
                    else:
                        self.logger.warning(f"epoch_ms tipo inv√°lido: {type(epoch_ms)}")
                        
                elif timestamp:
                    try:
                        dt = self._parse_iso8601(timestamp)
                    except Exception as e:
                        self.logger.error(f"timestamp inv√°lido {timestamp}: {e}")

            if dt:
                now = datetime.now(UTC_TZ)
                time_diff = abs((dt - now).total_seconds())
                
                if time_diff > 86400:
                    event["data_context"] = "historical"
                else:
                    event["data_context"] = "real_time"
                
                # Adiciona timestamps
                event["timestamp_utc"] = dt.strftime("%Y-%m-%d %H:%M:%S UTC")
                
                if TIMEZONE_AVAILABLE or hasattr(NY_TZ, 'get_offset'):
                    dt_ny = self._convert_timezone(dt, NY_TZ)
                    dt_sp = self._convert_timezone(dt, SP_TZ)
                    event["timestamp_ny"] = dt_ny.strftime("%Y-%m-%d %H:%M:%S EST/EDT")
                    event["timestamp_sp"] = dt_sp.strftime("%Y-%m-%d %H:%M:%S BRT")
                else:
                    dt_ny = dt.replace(tzinfo=UTC_TZ).astimezone(NY_TZ)
                    dt_sp = dt.replace(tzinfo=UTC_TZ).astimezone(SP_TZ)
                    event["timestamp_ny"] = dt_ny.strftime("%Y-%m-%d %H:%M:%S") + " (EST)"
                    event["timestamp_sp"] = dt_sp.strftime("%Y-%m-%d %H:%M:%S") + " (BRT)"
                
                if "timestamp" not in event:
                    event["timestamp"] = dt.isoformat(timespec="milliseconds")
            else:
                event["data_context"] = "unknown"
                self.logger.warning("Evento sem timestamp v√°lido")

            # Enriquece eventos simples
            if event.get("tipo_evento") == "Alerta" and "context" in event:
                context = event["context"]
                enriched = {
                    "price_data": {
                        "current": {
                            "last": context.get("price"),
                            "volume": context.get("volume")
                        }
                    },
                    "volatility_metrics": {
                        "realized_vol_24h": context.get("volatility")
                    },
                    "market_context": {
                        "trading_session": "NY_OVERLAP",
                        "session_phase": "ACTIVE"
                    }
                }
                event.update(enriched)

            # Detecta nova janela
            window_id = event.get("window_id") or event.get("candle_id_ms") or event.get("epoch_ms")
            if dt and window_id:
                window_time = dt.replace(second=0, microsecond=0)
                window_key = window_time.strftime("%Y%m%d_%H%M")
                
                if window_key != self.last_window_id:
                    self._window_counter += 1
                    event["janela_numero"] = self._window_counter
                    # ‚úÖ CORRE√á√ÉO 2: Define flag em vez de chamar separador diretamente
                    event["_needs_separator"] = True
                    self.last_window_id = window_key

            # Buffer com limite
            with self._buffer_lock:
                if len(self._write_buffer) >= MAX_BUFFER_SIZE:
                    self._buffer_overflow_count += 1
                    self.logger.warning(
                        f"‚ö†Ô∏è Buffer overflow ({len(self._write_buffer)}/{MAX_BUFFER_SIZE}), "
                        f"for√ßando flush..."
                    )
                    # For√ßa flush s√≠ncrono
                    buffer_copy = self._write_buffer.copy()
                    self._write_buffer.clear()
                    self._flush_buffer(buffer_copy)
                
                self._write_buffer.append(event)

            # Alerta sonoro
            if self.sound_alert and event.get("is_signal", False):
                self._play_sound()

        except Exception as e:
            self.logger.error(f"Erro cr√≠tico ao processar evento: {e}", exc_info=True)

    def _add_visual_separator(self, event: Dict):
        """Adiciona separador visual para nova janela de tempo."""
        try:
            epoch_ms = event.get("epoch_ms") or event.get("window_close_ms")
            
            if epoch_ms and isinstance(epoch_ms, (int, float, str)):
                try:
                    epoch_ms_int = int(epoch_ms)
                    dt_utc = datetime.fromtimestamp(epoch_ms_int / 1000, tz=UTC_TZ)
                    
                    if TIMEZONE_AVAILABLE or hasattr(NY_TZ, 'get_offset'):
                        dt_ny = self._convert_timezone(dt_utc, NY_TZ)
                        dt_sp = self._convert_timezone(dt_utc, SP_TZ)
                        timestamp_utc = dt_utc.strftime("%Y-%m-%d %H:%M:%S UTC")
                        timestamp_ny = dt_ny.strftime("%Y-%m-%d %H:%M:%S EST/EDT")
                        timestamp_sp = dt_sp.strftime("%Y-%m-%d %H:%M:%S BRT")
                    else:
                        dt_ny = dt_utc.replace(tzinfo=UTC_TZ).astimezone(NY_TZ)
                        dt_sp = dt_utc.replace(tzinfo=UTC_TZ).astimezone(SP_TZ)
                        timestamp_utc = dt_utc.strftime("%Y-%m-%d %H:%M:%S UTC")
                        timestamp_ny = dt_ny.strftime("%Y-%m-%d %H:%M:%S") + " (EST)"
                        timestamp_sp = dt_sp.strftime("%Y-%m-%d %H:%M:%S") + " (BRT)"
                except:
                    timestamp_utc = datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")
                    timestamp_ny = datetime.now().strftime("%Y-%m-%d %H:%M:%S") + " (EST)"
                    timestamp_sp = datetime.now().strftime("%Y-%m-%d %H:%M:%S") + " (BRT)"
            else:
                timestamp_utc = datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")
                timestamp_ny = datetime.now().strftime("%Y-%m-%d %H:%M:%S") + " (EST)"
                timestamp_sp = datetime.now().strftime("%Y-%m-%d %H:%M:%S") + " (BRT)"

            window_num = event.get("janela_numero", "NOVA")
            
            def safe_extract_time_and_zone(timestamp_str):
                """Extrai tempo e timezone de forma segura."""
                if not isinstance(timestamp_str, str):
                    return 'N/A', ''
                    
                parts = timestamp_str.split(' ')
                time_part = parts[1] if len(parts) > 1 else 'N/A'
                zone_part = ''
                
                if len(parts) > 2:
                    zone_part = parts[2]
                elif '(' in timestamp_str and ')' in timestamp_str:
                    match = PAREN_PATTERN.search(timestamp_str)
                    if match:
                        zone_part = f"({match.group(1)})"
                        
                return time_part, zone_part

            ny_time, ny_zone = safe_extract_time_and_zone(timestamp_ny)
            sp_time, sp_zone = safe_extract_time_and_zone(timestamp_sp)
            
            separator = f"\n{'='*100}\n"
            separator += f"üóìÔ∏è  JANELA {window_num}\n"
            separator += f"‚è∞ {timestamp_utc}\n"
            separator += f"üìç NY: {ny_time} {ny_zone}\n"
            separator += f"üìç S√£o Paulo: {sp_time} {sp_zone}\n"
            separator += f"üìä Contexto: {event.get('data_context', 'real_time')}\n"
            separator += f"{'='*100}\n"
            
            # ‚úÖ CORRE√á√ÉO 3: Adiciona file lock para evitar race condition
            lock_file = None
            lock_acquired = False
            
            try:
                lock_file_path = self.visual_log_file.with_suffix('.lock')
                lock_file = open(lock_file_path, 'w')
                lock_acquired = acquire_file_lock(lock_file, blocking=True, timeout=3.0)
                
                if lock_acquired:
                    with open(self.visual_log_file, "a", encoding="utf-8") as f:
                        f.write(separator)
                        f.flush()
                else:
                    self.logger.warning("Timeout ao adquirir lock do visual log")
                    
            except Exception as e:
                self.logger.error(f"Erro ao escrever separador: {e}")
                
            finally:
                if lock_file:
                    if lock_acquired:
                        release_file_lock(lock_file)
                    lock_file.close()
                    try:
                        lock_file_path.unlink(missing_ok=True)
                    except:
                        pass
                
        except Exception as e:
            self.logger.error(f"Erro ao adicionar separador: {e}")

    def _format_value_for_display(self, value: Any, key: str = "") -> str:
        """Formata valor para exibi√ß√£o leg√≠vel."""
        if value is None:
            return "null"
        if not HAS_FORMAT_UTILS:
            if isinstance(value, bool):
                return str(value).lower()
            elif isinstance(value, (int, float)):
                return f"{value:,.4f}" if isinstance(value, float) else str(value)
            else:
                return str(value)
        
        key_lower = key.lower()
        try:
            if isinstance(value, bool):
                return str(value).lower()
            elif isinstance(value, (int, float)):
                if any(x in key_lower for x in ['price', 'preco', 'poc', 'val', 'vah']):
                    return format_price(value)
                elif any(x in key_lower for x in ['volume', 'quantity', 'size']):
                    return format_large_number(value)
                elif 'delta' in key_lower:
                    return format_delta(value)
                elif any(x in key_lower for x in ['pct', 'percent', 'ratio']):
                    return format_percent(value)
                elif any(x in key_lower for x in ['volatility', 'returns', 'slope']):
                    return format_scientific(value)
                else:
                    return str(value)
            else:
                return str(value)
        except:
            return str(value)

    def _add_visual_log_entry(self, event: Dict):
        """Adiciona entrada formatada ao log visual."""
        try:
            epoch_ms = event.get("epoch_ms")
            timestamp = event.get("timestamp")
            dt = None
            
            if epoch_ms and isinstance(epoch_ms, (int, float, str)):
                try:
                    dt = datetime.fromtimestamp(int(epoch_ms) / 1000, tz=UTC_TZ)
                except:
                    pass
            elif timestamp:
                try:
                    dt = self._parse_iso8601(timestamp)
                except:
                    pass

            if dt:
                minute_key = dt.strftime("%Y-%m-%d %H:%M")
                context = event.get("data_context", "unknown")
                minute_block = f"{minute_key}|{context}"
                
                # Salva com timestamp para cleanup posterior
                event_key = (
                    str(event.get("timestamp")),
                    str(event.get("tipo_evento")),
                    str(event.get("volume_total"))
                )
                
                if event_key in self._seen_in_block:
                    return
                    
                self._seen_in_block[event_key] = time.time()

            clean_event = self._prepare_visual_event(event)
            
            with open(self.visual_log_file, "a", encoding="utf-8") as f:
                json_str = json.dumps(clean_event, indent=2, ensure_ascii=False, default=str)
                json_str = self._optimize_json_display(json_str)
                f.write(json_str + "\n")
                f.flush()
                
        except Exception as e:
            self.logger.error(f"Erro ao adicionar entrada visual: {e}")

    def _optimize_json_display(self, json_str: str) -> str:
        """Otimiza exibi√ß√£o de JSON."""
        def optimize_arrays(match):
            array_content = match.group(1)
            numbers = [x.strip() for x in array_content.split(',')]
            
            if len(numbers) > 10 and all(NUMBER_PATTERN.match(n) for n in numbers):
                if len(numbers) > 6:
                    optimized = numbers[:3] + ['...'] + numbers[-3:]
                    return '[' + ', '.join(optimized) + ']'
            return match.group(0)
        
        json_str = re.sub(r'\[([^\[\]]*)\]', optimize_arrays, json_str)
        return json_str

    def _prepare_visual_event(self, event: Dict) -> Dict:
        """Prepara evento para visualiza√ß√£o removendo redund√¢ncias."""
        clean = dict(event)
        
        fields_to_remove = ['time_ny', 'time_sp', 'time_utc', '_id', '_rev', '_key']
        for field in fields_to_remove:
            clean.pop(field, None)
        
        if 'contextual_snapshot' in clean:
            contextual = clean.get('contextual_snapshot', {})
            if isinstance(contextual, dict) and 'flow_metrics' in contextual:
                if 'flow_metrics' in clean:
                    clean['contextual_snapshot'] = {
                        k: v for k, v in contextual.items() 
                        if k != 'flow_metrics'
                    }
        
        def remove_empty(obj):
            if isinstance(obj, dict):
                result = {}
                for k, v in obj.items():
                    cleaned_v = remove_empty(v)
                    if cleaned_v is not None and cleaned_v != 0 and cleaned_v != "" and cleaned_v != []:
                        result[k] = cleaned_v
                return result if result else None
            elif isinstance(obj, list):
                result = [remove_empty(item) for item in obj if item is not None]
                return result if result else None
            return obj
        
        cleaned_event = remove_empty(clean)
        return cleaned_event if cleaned_event else clean

    def _play_sound(self):
        """Reproduz alerta sonoro multiplataforma."""
        try:
            system = platform.system()
            if system == "Windows":
                try:
                    import winsound
                    winsound.Beep(1000, 500)
                except ImportError:
                    print("\nüîî ALERTA: Sinal detectado! üîî\n")
            elif system == "Darwin":
                try:
                    import subprocess
                    subprocess.run(
                        ["afplay", "/System/Library/Sounds/Glass.aiff"], 
                        capture_output=True, 
                        timeout=2
                    )
                except:
                    print("\nüîî ALERTA: Sinal detectado! üîî\n")
            elif system == "Linux":
                try:
                    import subprocess
                    for cmd in [
                        ["paplay", "/usr/share/sounds/freedesktop/stereo/bell.oga"],
                        ["aplay", "/usr/share/sounds/alsa/Front_Center.wav"],
                        ["speaker-test", "-t", "sine", "-f", "1000", "-l", "1"]
                    ]:
                        try:
                            subprocess.run(cmd, capture_output=True, timeout=1)
                            break
                        except:
                            continue
                except:
                    print("\nüîî ALERTA: Sinal detectado! üîî\n")
            else:
                print("\nüîî ALERTA: Sinal detectado! üîî\n")
        except Exception as e:
            self.logger.debug(f"Som n√£o dispon√≠vel: {e}")
            print("\nüîî ALERTA: Sinal detectado! üîî\n")

    def get_stats(self) -> Dict[str, Any]:
        """Retorna estat√≠sticas de opera√ß√£o."""
        stats = {
            "buffer_size": len(self._write_buffer),
            "buffer_max": MAX_BUFFER_SIZE,
            "buffer_overflow_count": self._buffer_overflow_count,
            "lock_timeout_count": self._lock_timeout_count,
            "seen_in_block_size": len(self._seen_in_block),
            "seen_block_ttl_sec": SEEN_BLOCK_TTL,
            "last_cleanup_sec_ago": time.time() - self._last_cleanup_time,
            "cleanup_interval_sec": CLEANUP_INTERVAL,
            "lock_method": LOCK_METHOD or "disabled",
        }
        
        # ‚úÖ Adiciona stats de Clock Sync
        if HAS_CLOCK_SYNC and _clock_sync_instance:
            try:
                clock_stats = _clock_sync_instance.get_stats()
                stats["clock_sync"] = {
                    "enabled": True,
                    "synced": clock_stats.get('is_synced', False),
                    "offset_ms": clock_stats.get('offset_ms', 0),
                    "offset_seconds": clock_stats.get('offset_seconds', 0),
                }
            except:
                stats["clock_sync"] = {"enabled": False}
        else:
            stats["clock_sync"] = {"enabled": False}
        
        return stats


# ===== INST√ÇNCIA GLOBAL =====
_global_saver = None


def get_event_saver() -> EventSaver:
    """Retorna inst√¢ncia global do EventSaver."""
    global _global_saver
    if _global_saver is None:
        _global_saver = EventSaver()
    return _global_saver


# ===== HELPER PARA DEPEND√äNCIAS =====
def install_dependencies():
    """Helper para instalar depend√™ncias opcionais."""
    import subprocess
    import sys
    
    packages = []
    
    try:
        import pytz
    except ImportError:
        packages.append("pytz")
    
    try:
        import numpy
    except ImportError:
        packages.append("numpy")
    
    if packages:
        print(f"Instalando depend√™ncias opcionais: {', '.join(packages)}")
        subprocess.check_call([sys.executable, "-m", "pip", "install"] + packages)
        print("‚úÖ Depend√™ncias instaladas!")
    else:
        print("‚úÖ Todas as depend√™ncias j√° instaladas!")


# ===== TESTE =====
if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    print("Verificando depend√™ncias...")
    try:
        install_dependencies()
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao instalar depend√™ncias: {e}")
        print("Execute manualmente: pip install pytz numpy")
    
    print("\n" + "="*80)
    print("üß™ TESTE DO EVENTSAVER v4.5.1 - CORRE√á√ÉO DE JANELAS VAZIAS")
    print("="*80 + "\n")
    
    saver = EventSaver(sound_alert=False)
    
    # Evento de teste
    test_event = {
        "tipo_evento": "institucional_snapshot",
        "is_signal": True,
        "price_data": {
            "current": {
                "last": 111500.00,
                "volume": 125.5
            }
        },
        "order_flow": {
            "net_flow_1m": -125000,
            "buy_sell_ratio": 0.84
        }
    }
    
    print("1. Salvando evento de teste...")
    saver.save_event(test_event)
    
    print("2. Aguardando flush...")
    time.sleep(6)
    
    print("\n3. Estat√≠sticas:")
    stats = saver.get_stats()
    for key, val in stats.items():
        if isinstance(val, dict):
            print(f"   {key}:")
            for k, v in val.items():
                print(f"      {k}: {v}")
        else:
            print(f"   {key}: {val}")
    
    print("\n4. Parando EventSaver...")
    saver.stop()
    
    print(f"\n‚úÖ Teste conclu√≠do!")
    print(f"üìÅ Arquivos em: {DATA_DIR.absolute()}")
    
    print("\nüîß CORRE√á√ïES APLICADAS:")
    print("   ‚úÖ v4.5.1: Separador agora √© processado no flush (n√£o mais s√≠ncrono)")
    print("   ‚úÖ v4.5.1: Race condition corrigida")
    print("   ‚úÖ v4.5.1: File lock adicionado ao separador")
    
    if HAS_CLOCK_SYNC:
        print("\nüïê Clock Sync: ATIVO")
    else:
        print("\n‚ö†Ô∏è Clock Sync: N√ÉO DISPON√çVEL")
        print("   ‚Üí Crie o arquivo clock_sync.py para habilitar")
    
    print("="*80 + "\n")