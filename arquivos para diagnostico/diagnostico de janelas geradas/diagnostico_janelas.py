# diagnostico_janelas.py - v1.0

import json
import re
from pathlib import Path
from datetime import datetime
from collections import defaultdict, Counter

class DiagnosticoJanelas:
    """Diagnostica discrep√¢ncia entre janelas no terminal e JSON"""
    
    def __init__(self):
        self.dados_dir = Path("dados")
        self.visual_log = self.dados_dir / "eventos_visuais.log"
        self.json_file = self.dados_dir / "eventos-fluxo.json"
        self.jsonl_file = self.dados_dir / "eventos_fluxo.jsonl"
        
    def executar(self):
        """Executa diagn√≥stico completo"""
        print("\n" + "="*100)
        print("üîç DIAGN√ìSTICO DE JANELAS - COMPARA√á√ÉO TERMINAL vs JSON")
        print("="*100 + "\n")
        
        # 1. Analisa log visual (terminal)
        janelas_terminal = self.analisar_log_visual()
        
        # 2. Analisa JSON
        janelas_json = self.analisar_json()
        
        # 3. Analisa JSONL (hist√≥rico)
        janelas_jsonl = self.analisar_jsonl()
        
        # 4. Compara
        self.comparar_janelas(janelas_terminal, janelas_json, janelas_jsonl)
        
        # 5. Detecta padr√µes
        self.detectar_padroes(janelas_terminal, janelas_json)
        
        # 6. Recomenda√ß√µes
        self.gerar_recomendacoes(janelas_terminal, janelas_json)
        
    def analisar_log_visual(self):
        """Analisa eventos_visuais.log"""
        print("üìÑ Analisando eventos_visuais.log (TERMINAL)...")
        print("-" * 100)
        
        if not self.visual_log.exists():
            print("‚ùå Arquivo n√£o encontrado!\n")
            return {}
        
        with open(self.visual_log, 'r', encoding='utf-8') as f:
            conteudo = f.read()
        
        # Regex para separadores
        separador_pattern = re.compile(
            r'={70,}\n'
            r'üóìÔ∏è\s+JANELA\s+(\d+)\n'
            r'‚è∞\s+(.+?)\n'
            r'üìç\s+NY:\s+(.+?)\n'
            r'üìç\s+S√£o Paulo:\s+(.+?)\n'
            r'üìä\s+Contexto:\s+(.+?)\n'
            r'={70,}'
        )
        
        janelas = {}
        matches = list(separador_pattern.finditer(conteudo))
        
        for i, match in enumerate(matches):
            janela_num = int(match.group(1))
            timestamp_utc = match.group(2).strip()
            timestamp_ny = match.group(3).strip()
            timestamp_sp = match.group(4).strip()
            contexto = match.group(5).strip()
            
            # Pega conte√∫do at√© pr√≥ximo separador
            inicio = match.end()
            if i < len(matches) - 1:
                fim = matches[i + 1].start()
            else:
                fim = len(conteudo)
            
            conteudo_janela = conteudo[inicio:fim].strip()
            
            # Conta eventos JSON na janela
            eventos_json = conteudo_janela.count('"tipo_evento"')
            tem_conteudo = len(conteudo_janela) > 50
            
            janelas[janela_num] = {
                'numero': janela_num,
                'timestamp_utc': timestamp_utc,
                'timestamp_ny': timestamp_ny,
                'timestamp_sp': timestamp_sp,
                'contexto': contexto,
                'tamanho_bytes': len(conteudo_janela),
                'tem_conteudo': tem_conteudo,
                'eventos_count': eventos_json,
                'pos_arquivo': match.start(),
                'origem': 'terminal'
            }
        
        print(f"‚úÖ Total de janelas no terminal: {len(janelas)}")
        
        vazias = sum(1 for j in janelas.values() if not j['tem_conteudo'])
        print(f"   - Com conte√∫do: {len(janelas) - vazias}")
        print(f"   - Vazias: {vazias}")
        
        if janelas:
            print(f"   - Primeira janela: {min(janelas.keys())}")
            print(f"   - √öltima janela: {max(janelas.keys())}")
        
        print()
        return janelas
    
    def analisar_json(self):
        """Analisa eventos-fluxo.json"""
        print("üìÑ Analisando eventos-fluxo.json (SNAPSHOT)...")
        print("-" * 100)
        
        if not self.json_file.exists():
            print("‚ùå Arquivo n√£o encontrado!\n")
            return {}
        
        try:
            with open(self.json_file, 'r', encoding='utf-8') as f:
                eventos = json.load(f)
        except json.JSONDecodeError as e:
            print(f"‚ùå Erro ao ler JSON: {e}\n")
            return {}
        
        if not isinstance(eventos, list):
            print(f"‚ö†Ô∏è Formato inesperado: {type(eventos)}\n")
            return {}
        
        janelas = {}
        por_janela = defaultdict(list)
        
        for i, evento in enumerate(eventos):
            janela_num = evento.get('janela_numero')
            if janela_num:
                por_janela[janela_num].append({
                    'index': i,
                    'tipo_evento': evento.get('tipo_evento', 'N/A'),
                    'timestamp': evento.get('timestamp', evento.get('timestamp_utc', 'N/A')),
                    'epoch_ms': evento.get('epoch_ms'),
                    'is_signal': evento.get('is_signal', False),
                    'evento': evento
                })
        
        for janela_num, eventos_janela in por_janela.items():
            primeiro = eventos_janela[0]
            ultimo = eventos_janela[-1]
            
            janelas[janela_num] = {
                'numero': janela_num,
                'eventos_count': len(eventos_janela),
                'primeiro_timestamp': primeiro['timestamp'],
                'ultimo_timestamp': ultimo['timestamp'],
                'primeiro_epoch': primeiro['epoch_ms'],
                'ultimo_epoch': ultimo['epoch_ms'],
                'tipos_eventos': [e['tipo_evento'] for e in eventos_janela],
                'tem_signals': any(e['is_signal'] for e in eventos_janela),
                'eventos': eventos_janela,
                'origem': 'json'
            }
        
        print(f"‚úÖ Total de eventos no JSON: {len(eventos)}")
        print(f"‚úÖ Total de janelas no JSON: {len(janelas)}")
        
        if janelas:
            print(f"   - Primeira janela: {min(janelas.keys())}")
            print(f"   - √öltima janela: {max(janelas.keys())}")
            
            # Estat√≠sticas por janela
            eventos_por_janela = [j['eventos_count'] for j in janelas.values()]
            print(f"   - M√©dia de eventos/janela: {sum(eventos_por_janela)/len(eventos_por_janela):.1f}")
            print(f"   - M√≠n eventos/janela: {min(eventos_por_janela)}")
            print(f"   - M√°x eventos/janela: {max(eventos_por_janela)}")
        
        print()
        return janelas
    
    def analisar_jsonl(self):
        """Analisa eventos_fluxo.jsonl (hist√≥rico)"""
        print("üìÑ Analisando eventos_fluxo.jsonl (HIST√ìRICO)...")
        print("-" * 100)
        
        if not self.jsonl_file.exists():
            print("‚ùå Arquivo n√£o encontrado!\n")
            return {}
        
        janelas = defaultdict(list)
        total_linhas = 0
        
        with open(self.jsonl_file, 'r', encoding='utf-8') as f:
            for linha in f:
                total_linhas += 1
                try:
                    evento = json.loads(linha.strip())
                    janela_num = evento.get('janela_numero')
                    if janela_num:
                        janelas[janela_num].append(evento)
                except json.JSONDecodeError:
                    continue
        
        print(f"‚úÖ Total de linhas no JSONL: {total_linhas}")
        print(f"‚úÖ Total de janelas no JSONL: {len(janelas)}")
        
        if janelas:
            print(f"   - Primeira janela: {min(janelas.keys())}")
            print(f"   - √öltima janela: {max(janelas.keys())}")
        
        print()
        return dict(janelas)
    
    def comparar_janelas(self, terminal, json_data, jsonl_data):
        """Compara janelas entre terminal e JSON"""
        print("üîÑ COMPARA√á√ÉO ENTRE FONTES")
        print("="*100)
        
        nums_terminal = set(terminal.keys())
        nums_json = set(json_data.keys())
        nums_jsonl = set(jsonl_data.keys())
        
        # Estat√≠sticas
        print(f"\nüìä CONTADORES:")
        print(f"   Terminal (log visual):  {len(nums_terminal)} janelas")
        print(f"   JSON (snapshot):        {len(nums_json)} janelas")
        print(f"   JSONL (hist√≥rico):      {len(nums_jsonl)} janelas")
        
        # Diferen√ßas
        print(f"\nüîç DIFEREN√áAS:")
        
        apenas_terminal = nums_terminal - nums_json
        apenas_json = nums_json - nums_terminal
        em_ambos = nums_terminal & nums_json
        
        if apenas_json:
            print(f"\n‚ùå Janelas APENAS no JSON (n√£o aparecem no terminal): {sorted(apenas_json)}")
            print(f"   Total: {len(apenas_json)} janelas")
            
            # Detalhes das janelas que faltam
            print(f"\n   üìã Detalhes:")
            for num in sorted(apenas_json)[:10]:  # Limita a 10
                j = json_data[num]
                print(f"      Janela {num}: {j['eventos_count']} eventos | "
                      f"Timestamp: {j['primeiro_timestamp']}")
                print(f"         Tipos: {Counter(j['tipos_eventos']).most_common(3)}")
        
        if apenas_terminal:
            print(f"\n‚ö†Ô∏è Janelas APENAS no terminal (n√£o est√£o no JSON): {sorted(apenas_terminal)}")
            print(f"   Total: {len(apenas_terminal)} janelas")
        
        print(f"\n‚úÖ Janelas em AMBOS: {len(em_ambos)}")
        
        # Verifica sequ√™ncia
        print(f"\nüìà AN√ÅLISE DE SEQU√äNCIA:")
        
        todos_nums = sorted(nums_terminal | nums_json)
        if todos_nums:
            esperado = list(range(min(todos_nums), max(todos_nums) + 1))
            faltando = set(esperado) - set(todos_nums)
            
            if faltando:
                print(f"   ‚ùå Janelas faltando na sequ√™ncia: {sorted(faltando)}")
            else:
                print(f"   ‚úÖ Sequ√™ncia cont√≠nua de {min(todos_nums)} at√© {max(todos_nums)}")
            
            # Verifica duplicatas
            all_nums = list(terminal.keys()) + list(json_data.keys())
            duplicatas = [n for n, count in Counter(all_nums).items() if count > 1]
            
            if duplicatas:
                print(f"   ‚ö†Ô∏è N√∫meros duplicados: {duplicatas}")
        
        print()
    
    def detectar_padroes(self, terminal, json_data):
        """Detecta padr√µes temporais"""
        print("üïê AN√ÅLISE TEMPORAL")
        print("="*100)
        
        if not json_data:
            print("‚ùå Sem dados JSON para an√°lise\n")
            return
        
        # Analisa epochs
        epochs = []
        for janela_num, dados in sorted(json_data.items()):
            if dados.get('primeiro_epoch'):
                epochs.append({
                    'janela': janela_num,
                    'epoch': dados['primeiro_epoch'],
                    'timestamp': dados['primeiro_timestamp']
                })
        
        if len(epochs) < 2:
            print("‚ö†Ô∏è Dados insuficientes\n")
            return
        
        # Calcula intervalos
        intervalos = []
        for i in range(len(epochs) - 1):
            diff_ms = epochs[i+1]['epoch'] - epochs[i]['epoch']
            diff_seg = diff_ms / 1000
            intervalos.append({
                'janela_de': epochs[i]['janela'],
                'janela_ate': epochs[i+1]['janela'],
                'intervalo_ms': diff_ms,
                'intervalo_seg': diff_seg
            })
        
        if intervalos:
            int_segs = [i['intervalo_seg'] for i in intervalos]
            
            print(f"üìä Intervalos entre janelas:")
            print(f"   M√©dia: {sum(int_segs)/len(int_segs):.1f}s")
            print(f"   M√≠nimo: {min(int_segs):.1f}s")
            print(f"   M√°ximo: {max(int_segs):.1f}s")
            
            # Detecta anomalias (intervalos muito pequenos ou grandes)
            media = sum(int_segs) / len(int_segs)
            anomalias = [i for i in intervalos if abs(i['intervalo_seg'] - media) > media * 0.5]
            
            if anomalias:
                print(f"\n   ‚ö†Ô∏è Anomalias detectadas ({len(anomalias)}):")
                for a in anomalias[:5]:
                    print(f"      Janela {a['janela_de']} ‚Üí {a['janela_ate']}: "
                          f"{a['intervalo_seg']:.1f}s")
            
            # Verifica cria√ß√£o simult√¢nea (mesmo segundo)
            mesmo_segundo = defaultdict(list)
            for e in epochs:
                segundo = int(e['epoch'] / 1000)
                mesmo_segundo[segundo].append(e['janela'])
            
            simultaneas = {k: v for k, v in mesmo_segundo.items() if len(v) > 1}
            
            if simultaneas:
                print(f"\n   üî¥ Janelas criadas no mesmo segundo ({len(simultaneas)} ocorr√™ncias):")
                for segundo, janelas in list(simultaneas.items())[:5]:
                    dt = datetime.fromtimestamp(segundo)
                    print(f"      {dt.strftime('%H:%M:%S')}: Janelas {janelas}")
                
                print(f"\n   üí° CAUSA PROV√ÅVEL: M√∫ltiplos eventos processados simultaneamente")
                print(f"      ‚Üí Verificar l√≥gica de detec√ß√£o de nova janela")
        
        print()
    
    def gerar_recomendacoes(self, terminal, json_data):
        """Gera recomenda√ß√µes de corre√ß√£o"""
        print("üí° RECOMENDA√á√ïES")
        print("="*100 + "\n")
        
        apenas_json = set(json_data.keys()) - set(terminal.keys())
        
        if len(apenas_json) > 0:
            print("üî¥ PROBLEMA: Janelas no JSON mas n√£o no terminal")
            print("-" * 100)
            print(f"   Quantidade: {len(apenas_json)} janelas")
            print(f"   Janelas: {sorted(apenas_json)}\n")
            
            print("üìã POSS√çVEIS CAUSAS:")
            print("   1. ‚ùå Separador n√£o sendo escrito (lock timeout)")
            print("   2. ‚ùå Buffer processando fora de ordem")
            print("   3. ‚ùå Flag '_needs_separator' sendo removida antes do flush")
            print("   4. ‚ùå M√∫ltiplas threads criando janelas simult√¢neas\n")
            
            print("üîß SOLU√á√ïES:")
            print("   1. Verificar logs de 'Timeout ao adquirir lock do visual log'")
            print("   2. Verificar se _flush_buffer est√° processando a flag corretamente")
            print("   3. Adicionar log em _add_visual_separator para debug")
            print("   4. Aumentar timeout do lock (linha ~870 event_saver.py)\n")
            
            print("üß™ TESTE RECOMENDADO:")
            print("   python teste_separador.py  # (script abaixo)\n")
        
        # Verifica se h√° janelas simult√¢neas
        if json_data:
            epochs_por_segundo = defaultdict(list)
            for num, dados in json_data.items():
                if dados.get('primeiro_epoch'):
                    segundo = int(dados['primeiro_epoch'] / 1000)
                    epochs_por_segundo[segundo].append(num)
            
            simultaneas = {k: v for k, v in epochs_por_segundo.items() if len(v) > 1}
            
            if simultaneas:
                print("üî¥ PROBLEMA: M√∫ltiplas janelas no mesmo segundo")
                print("-" * 100)
                print(f"   Ocorr√™ncias: {len(simultaneas)}")
                print(f"\nüìã CAUSA:")
                print(f"   L√≥gica de detec√ß√£o est√° criando nova janela para cada evento")
                print(f"   em vez de agrupar por minuto\n")
                
                print("üîß SOLU√á√ÉO:")
                print("   Linha ~775 event_saver.py:")
                print("   window_time = dt.replace(second=0, microsecond=0)  # ‚úÖ J√° correto")
                print("   window_key = window_time.strftime('%Y%m%d_%H%M')  # ‚úÖ Agrupa por minuto")
                print("\n   ‚ö†Ô∏è MAS: Verificar se 'window_id' est√° mudando a cada segundo")
                print("   Solu√ß√£o: Usar epoch do MINUTO, n√£o do segundo:\n")
                print("   # ADICIONAR ap√≥s linha 774:")
                print("   window_id = int(window_time.timestamp() * 1000)  # epoch do minuto")
                print()


def gerar_teste_separador():
    """Gera script de teste para debug"""
    codigo = '''# teste_separador.py - Debug de separadores

import logging
import time
from event_saver import EventSaver
from datetime import datetime

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

print("üß™ TESTE DE SEPARADORES\\n")
print("="*80)

saver = EventSaver(sound_alert=False)

# For√ßa cria√ß√£o de 5 janelas diferentes
for i in range(5):
    epoch_base = int(datetime.now().timestamp() * 1000)
    epoch_minuto = (epoch_base // 60000) * 60000  # Arredonda para minuto
    epoch_minuto += i * 60000  # Adiciona 1 minuto por itera√ß√£o
    
    evento = {
        "tipo_evento": f"TESTE_JANELA_{i+1}",
        "is_signal": True,
        "epoch_ms": epoch_minuto,
        "window_id": epoch_minuto,
        "price_data": {
            "current": {
                "last": 110000 + i * 100,
                "volume": 100 + i
            }
        }
    }
    
    print(f"\\nüìå Salvando evento {i+1} (epoch: {epoch_minuto})...")
    saver.save_event(evento)
    time.sleep(0.5)

print("\\n‚è≥ Aguardando flush...")
time.sleep(7)

print("\\nüìä Estat√≠sticas:")
stats = saver.get_stats()
for k, v in stats.items():
    if isinstance(v, dict):
        print(f"  {k}:")
        for k2, v2 in v.items():
            print(f"    {k2}: {v2}")
    else:
        print(f"  {k}: {v}")

saver.stop()

print("\\n‚úÖ Teste conclu√≠do!")
print("\\nüîç Agora execute:")
print("   python diagnostico_janelas.py")
print("="*80)
'''
    
    with open('teste_separador.py', 'w', encoding='utf-8') as f:
        f.write(codigo)
    
    print("‚úÖ Arquivo 'teste_separador.py' criado!")


if __name__ == "__main__":
    diag = DiagnosticoJanelas()
    diag.executar()
    
    print("\n" + "="*100)
    resposta = input("ü§î Deseja gerar script de teste? (s/n): ").lower()
    
    if resposta == 's':
        gerar_teste_separador()
        print("\nüìù Execute:")
        print("   python teste_separador.py")
        print("   python diagnostico_janelas.py  # para verificar resultado")
    
    print("\n" + "="*100)