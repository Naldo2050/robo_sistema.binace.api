# ai_analyzer_qwen.py
import logging
import os
import random
import time
from typing import Any, Dict

# Tentativa de importar OpenAI (modo compat√≠vel)
try:
    from openai import OpenAI
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    logging.warning("OpenAI n√£o instalado. Para usar API real: pip install openai")

# Tentativa de importar DashScope (modo nativo)
try:
    import dashscope
    from dashscope import Generation
    DASHSCOPE_AVAILABLE = True
except ImportError:
    DASHSCOPE_AVAILABLE = False
    logging.warning("DashScope n√£o instalado. Para usar API real: pip install dashscope")

class AIAnalyzer:
    def __init__(self, headless: bool = True, user_data_dir: str = "./qwen_data"):
        self.enabled = True
        self.use_advanced_analysis = True
        self.use_mock = True  # Inicia com simula√ß√£o at√© testar API
        self.api_mode = None  # 'openai', 'dashscope', ou 'mock'
        self.client = None
        
        # Configura chave API
        self.api_key = os.getenv('DASHSCOPE_API_KEY')
        if not self.api_key:
            self.api_key = "sk-718563fc96564790af405699dd0c6e85"  # Fallback
            logging.warning("‚ö†Ô∏è Usando chave API hardcoded. Configure DASHSCOPE_API_KEY no ambiente.")
        
        # Tenta inicializar a API
        self._initialize_api()
        
        logging.info("üß† IA Analyzer Qwen inicializada - An√°lise avan√ßada ativada")

    def _initialize_api(self):
        """Inicializa a API preferencial dispon√≠vel."""
        
        # Prioridade 1: OpenAI compat√≠vel (mais est√°vel)
        if OPENAI_AVAILABLE:
            try:
                self.client = OpenAI(
                    api_key=self.api_key,
                    base_url="https://dashscope-intl.aliyuncs.com/compatible-mode/v1"
                )
                logging.info("üîß OpenAI client configurado (modo compat√≠vel)")
                return
            except Exception as e:
                logging.warning(f"Erro ao configurar OpenAI client: {e}")
        
        # Prioridade 2: DashScope nativo
        if DASHSCOPE_AVAILABLE:
            try:
                dashscope.api_key = self.api_key
                dashscope.base_http_api_url = 'https://dashscope-intl.aliyuncs.com/api/v1'
                logging.info("üîß DashScope configurado (modo nativo)")
                return
            except Exception as e:
                logging.warning(f"Erro ao configurar DashScope: {e}")
        
        logging.info("üé≠ Nenhuma API dispon√≠vel - usando apenas simula√ß√£o")

    def _create_prompt(self, event_data: Dict[str, Any]) -> str:
        """Cria o prompt otimizado para an√°lise de eventos de mercado."""
        tipo_evento = event_data.get("tipo_evento", "N/A")
        ativo = event_data.get("ativo", "N/A")
        descricao = event_data.get("descricao", "Sem descri√ß√£o.")
        delta = float(event_data.get("delta", 0.0) or 0.0)
        volume_total = float(event_data.get("volume_total", 0.0) or 0.0)
        preco_fechamento = float(event_data.get("preco_fechamento", 0.0) or 0.0)
        volume_compra = float(event_data.get("volume_compra", 0.0) or 0.0)
        volume_venda = float(event_data.get("volume_venda", 0.0) or 0.0)

        contexto_extra = ""
        if event_data.get("contexto_sma"):
            contexto_extra += f"- **Contexto SMA:** {event_data.get('contexto_sma')}\n"
        if event_data.get("indice_absorcao") is not None:
            try:
                contexto_extra += f"- **√çndice de Absor√ß√£o:** {float(event_data.get('indice_absorcao')):.2f}\n"
            except Exception:
                contexto_extra += f"- **√çndice de Absor√ß√£o:** {event_data.get('indice_absorcao')}\n"

        prompt = f"""Analise este evento de mercado como um especialista em order flow:

**DADOS DO EVENTO:**
- Ativo: {ativo}
- Tipo: {tipo_evento}
- Descri√ß√£o: {descricao}
- Delta: {delta:.2f}
- Volume Total: {volume_total:.0f}
- Volume Compra: {volume_compra:.0f}
- Volume Venda: {volume_venda:.0f}
- Pre√ßo Fechamento: ${preco_fechamento:.2f}
{contexto_extra}

**AN√ÅLISE SOLICITADA:**
Forne√ßa uma an√°lise concisa (m√°ximo 150 palavras) respondendo:

1. **Interpreta√ß√£o:** O que este evento revela sobre o fluxo de ordens?
2. **For√ßa Dominante:** Compradores ou vendedores est√£o no controle?
3. **Expectativa:** Qual movimento √© mais prov√°vel no curto prazo?
4. **A√ß√£o:** Recomenda√ß√£o pr√°tica para este cen√°rio.

Seja direto e objetivo."""
        return prompt

    def _call_openai_compatible(self, prompt: str) -> str:
        """Chama a API no modo OpenAI compat√≠vel."""
        try:
            response = self.client.chat.completions.create(
                model="qwen-plus",
                messages=[
                    {"role": "system", "content": "Voc√™ √© um analista especialista em order flow e trading algor√≠tmico."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=512,
                temperature=0.3,
                top_p=0.8
            )
            
            if response.choices and len(response.choices) > 0:
                return response.choices[0].message.content.strip()
            return ""
            
        except Exception as e:
            logging.error(f"Erro na API OpenAI compat√≠vel: {e}")
            return ""

    def _call_dashscope_native(self, prompt: str) -> str:
        """Chama a API no modo DashScope nativo."""
        try:
            response = Generation.call(
                model="qwen-plus",
                messages=[
                    {"role": "system", "content": "Voc√™ √© um analista especialista em order flow e trading algor√≠tmico."},
                    {"role": "user", "content": prompt}
                ],
                result_format="message",
                max_tokens=512,
                temperature=0.3,
                top_p=0.8
            )
            
            if hasattr(response, 'status_code') and response.status_code == 200:
                if hasattr(response, 'output') and response.output:
                    choices = response.output.get('choices', [])
                    if choices and len(choices) > 0:
                        message = choices[0].get('message', {})
                        return message.get('content', '').strip()
            
            logging.error(f"Erro DashScope: status={getattr(response, 'status_code', 'N/A')}")
            return ""
            
        except Exception as e:
            logging.error(f"Erro na API DashScope: {e}")
            return ""

    def _generate_mock_analysis(self, event_data: Dict[str, Any]) -> str:
        """Gera uma an√°lise simulada baseada nos dados do evento."""
        tipo_evento = event_data.get("tipo_evento", "N/A")
        ativo = event_data.get("ativo", "BTCUSDT")
        delta = float(event_data.get("delta", 0.0) or 0.0)
        volume_compra = float(event_data.get("volume_compra", 0.0) or 0.0)
        volume_venda = float(event_data.get("volume_venda", 0.0) or 0.0)
        volume_total = float(event_data.get("volume_total", 0.0) or 0.0)
        
        templates = {
            "Demanda Forte": [
                f"**üü¢ Interpreta√ß√£o:** Fluxo agressivo de compras no {ativo}. Delta {delta:.1f} confirma absor√ß√£o eficiente da oferta pelos compradores.\n\n**For√ßa Dominante:** Bulls controlam com {(volume_compra/max(volume_total,1)*100):.1f}% do volume total.\n\n**Expectativa:** Momentum altista sustentado se continuar o fluxo.\n\n**A√ß√£o:** Posi√ß√µes compradas em pullbacks. Stop loss ajustado nos suportes.",
                
                f"**üî• Interpreta√ß√£o:** Press√£o compradora institucional detectada. Delta {delta:.1f} indica desequil√≠brio favor√°vel aos bulls.\n\n**For√ßa Dominante:** Smart money acumulando posi√ß√µes.\n\n**Expectativa:** Rompimento de resist√™ncias pr√≥ximas prov√°vel.\n\n**A√ß√£o:** Aguarde confirma√ß√£o de continuidade. Risk management rigoroso."
            ],
            
            "Press√£o de Venda": [
                f"**üî¥ Interpreta√ß√£o:** Distribui√ß√£o agressiva identificada. Delta negativo de {delta:.1f} revela press√£o vendedora institucional.\n\n**For√ßa Dominante:** Bears dominam o tape com {volume_venda:.0f} em volume.\n\n**Expectativa:** Teste de suportes inferiores iminente.\n\n**A√ß√£o:** Cautela em longs. Considere prote√ß√µes ou posi√ß√µes short.",
                
                f"**‚ö†Ô∏è Interpreta√ß√£o:** Absor√ß√£o fraca dos compradores. Delta {delta:.1f} sinaliza capitula√ß√£o.\n\n**For√ßa Dominante:** Vendedores controlam o order flow.\n\n**Expectativa:** Continua√ß√£o baixista at√© estabiliza√ß√£o.\n\n**A√ß√£o:** Aguarde sinais de revers√£o antes de comprar."
            ],
            
            "Alerta de Liquidez": [
                f"**‚ö° Interpreta√ß√£o:** Desequil√≠brio cr√≠tico de liquidez no {ativo}. Paredes significativas podem gerar breakout explosivo.\n\n**For√ßa Dominante:** Assimetria na liquidez criando tens√£o.\n\n**Expectativa:** Movimento violento na dire√ß√£o do rompimento.\n\n**A√ß√£o:** Posi√ß√£o reduzida at√© confirma√ß√£o de dire√ß√£o. Prepare-se para volatilidade.",
                
                f"**üéØ Interpreta√ß√£o:** Market makers posicionando grandes volumes. Concentra√ß√£o an√¥mala de ordens detectada.\n\n**For√ßa Dominante:** Institucionais preparando movimento.\n\n**Expectativa:** Breakout violento quando absorvidas as paredes.\n\n**A√ß√£o:** Evite contra-tend√™ncia. Siga a dire√ß√£o confirmada."
            ],
            
            "Absor√ß√£o": [
                f"**üìä Interpreta√ß√£o:** Smart money processando {volume_total:.0f} em volume sem impacto no pre√ßo. Acumula√ß√£o/distribui√ß√£o ativa.\n\n**For√ßa Dominante:** Equil√≠brio tempor√°rio entre for√ßas.\n\n**Expectativa:** Consolida√ß√£o at√© defini√ß√£o clara.\n\n**A√ß√£o:** Posi√ß√µes neutras. Aguarde rompimento confirmado.",
                
                f"**üü° Interpreta√ß√£o:** Absor√ß√£o institucional no {ativo}. Delta {delta:.1f} sugere processo de acumula√ß√£o.\n\n**For√ßa Dominante:** Grandes players ativos.\n\n**Expectativa:** Movimento direcional p√≥s-absor√ß√£o.\n\n**A√ß√£o:** Monitor cont√≠nuo. Siga o smart money."
            ]
        }
        
        event_templates = templates.get(tipo_evento, templates["Absor√ß√£o"])
        analysis = random.choice(event_templates)
        
        # Simula tempo de processamento
        time.sleep(random.uniform(1.0, 2.5))
        return analysis

    def test_connection(self) -> bool:
        """Testa conectividade com as APIs dispon√≠veis."""
        
        # Teste 1: OpenAI compat√≠vel
        if OPENAI_AVAILABLE and self.client:
            try:
                response = self.client.chat.completions.create(
                    model="qwen-plus",
                    messages=[{"role": "user", "content": "Responda: OK"}],
                    max_tokens=10
                )
                if response.choices and response.choices[0].message.content:
                    logging.info("‚úÖ API OpenAI compat√≠vel funcionando")
                    self.api_mode = 'openai'
                    self.use_mock = False
                    return True
            except Exception as e:
                logging.debug(f"OpenAI compat√≠vel falhou: {e}")
        
        # Teste 2: DashScope nativo
        if DASHSCOPE_AVAILABLE:
            try:
                response = Generation.call(
                    model="qwen-plus",
                    messages=[{"role": "user", "content": "Responda: OK"}],
                    result_format="message",
                    max_tokens=10
                )
                if hasattr(response, 'status_code') and response.status_code == 200:
                    logging.info("‚úÖ API DashScope nativa funcionando")
                    self.api_mode = 'dashscope'
                    self.use_mock = False
                    return True
            except Exception as e:
                logging.debug(f"DashScope nativo falhou: {e}")
        
        # Fallback para simula√ß√£o
        logging.info("‚ö†Ô∏è APIs indispon√≠veis - usando simula√ß√£o")
        self.api_mode = 'mock'
        self.use_mock = True
        return False

    def analyze_event(self, event_data: Dict[str, Any]) -> str:
        """Analisa um evento de mercado."""
        if not self.enabled:
            return "Analisador de IA desabilitado."

        # Se ainda n√£o testou, testa primeiro
        if self.api_mode is None:
            self.test_connection()

        prompt = self._create_prompt(event_data)
        logging.info(f"ü§ñ Analisando evento: {event_data.get('tipo_evento', 'N/A')}")

        analysis = ""
        
        # Tenta API real primeiro
        if self.api_mode == 'openai' and self.client:
            analysis = self._call_openai_compatible(prompt)
        elif self.api_mode == 'dashscope':
            analysis = self._call_dashscope_native(prompt)
        
        # Se API falhou ou n√£o h√° API, usa simula√ß√£o
        if not analysis or self.api_mode == 'mock':
            if self.api_mode != 'mock':
                logging.warning("üîÑ API falhou, usando simula√ß√£o como fallback")
            analysis = self._generate_mock_analysis(event_data)
            logging.info("üé≠ An√°lise simulada gerada")
        else:
            logging.info("‚úÖ An√°lise real da API gerada")

        return analysis

    def close(self):
        """Limpa recursos."""
        self.client = None

    def __del__(self):
        self.close()


if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")
    print("üß™ Teste do AIAnalyzer Qwen\n")

    # Inicializa analisador
    analyzer = AIAnalyzer()
    
    print("=== TESTE DE CONECTIVIDADE ===")
    connection_ok = analyzer.test_connection()
    print(f"Modo ativo: {analyzer.api_mode}")
    print(f"Usando simula√ß√£o: {analyzer.use_mock}\n")

    # Testes com diferentes tipos de eventos
    test_events = [
        {
            "tipo_evento": "Demanda Forte",
            "ativo": "BTCUSDT",
            "descricao": "Press√£o compradora detectada",
            "delta": 145.8,
            "volume_total": 2850,
            "preco_fechamento": 67500.0,
            "volume_compra": 1800,
            "volume_venda": 1050,
            "contexto_sma": "acima da SMA200",
            "indice_absorcao": 0.78
        },
        {
            "tipo_evento": "Alerta de Liquidez",
            "ativo": "ETHUSDT",
            "descricao": "Parede significativa",
            "delta": -32.4,
            "volume_total": 1650,
            "preco_fechamento": 3450.0,
            "volume_compra": 650,
            "volume_venda": 1000
        }
    ]

    for i, event in enumerate(test_events, 1):
        print(f"=== TESTE {i}: {event['tipo_evento']} ===")
        result = analyzer.analyze_event(event)
        print(f"{result}\n")
        print("-" * 70)

    analyzer.close()