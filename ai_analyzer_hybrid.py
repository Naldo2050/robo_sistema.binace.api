import logging
from datetime import datetime

class AIAnalyzer:
    def __init__(self, headless=True, user_data_dir="./hybrid_data"):
        self.enabled = True
        self.use_advanced_analysis = True
        logging.info("üß† IA Analyzer H√çBRIDA inicializada - An√°lise avan√ßada ativada")

    def _format_contexto_macro(self, event_data: dict) -> list:
        context_lines = []
        contexto = event_data.get("contexto_macro", {})
        if not contexto or not any(contexto.values()):
            return context_lines

        context_lines.append("üåê CONTEXTO DE MERCADO:")
        
        mtf = contexto.get("mtf_trends", {})
        if mtf:
            trends = [f"{tf.upper()}:{data.get('tendencia', 'N/A')[0]}" for tf, data in mtf.items()]
            context_lines.append(f"   ‚Üí Tend√™ncia (15m,1H,4H): {', '.join(trends)}")

        derivatives = contexto.get("derivatives", {}).get(event_data.get("ativo"), {})
        if derivatives:
            funding = derivatives.get('funding_rate_percent', 0)
            ls_ratio = derivatives.get('long_short_ratio', 0)
            long_liq = derivatives.get('longs_usd', 0)
            short_liq = derivatives.get('shorts_usd', 0)
            context_lines.append(f"   ‚Üí Futuros: Funding {funding:.4f}% | L/S {ls_ratio:.2f} | Liq L ${long_liq:,.0f} S ${short_liq:,.0f}")

        vp = event_data.get("historical_vp", {}).get("daily", {})
        if vp and vp.get('poc', 0) > 0:
            preco_atual = event_data.get('preco_fechamento', 0)
            poc, vah, val = vp.get('poc'), vp.get('vah'), vp.get('val')
            pos = "dentro da Value Area"
            if preco_atual > vah: pos = "acima da Value Area (Premium)"
            elif preco_atual < val: pos = "abaixo da Value Area (Discount)"
            context_lines.append(f"   ‚Üí Posi√ß√£o no Dia: Pre√ßo {pos} | POC @ ${poc:,.0f}")
        
        context_lines.append("")
        return context_lines

    def analyze_event(self, event_data: dict) -> str:
        try:
            tipo_evento = event_data.get("tipo_evento", "N/A")
            ativo = event_data.get("ativo", "N/A")
            delta = event_data.get("delta", 0); volume = event_data.get("volume_total", 0)
            preco = event_data.get("preco_fechamento", 0); volume_compra = event_data.get("volume_compra", 0)
            volume_venda = event_data.get("volume_venda", 0); indice_absorcao = event_data.get("indice_absorcao", 0)

            contexto = event_data.get("contexto_macro", {})
            atr15m = contexto.get("mtf_trends", {}).get("15m", {}).get("atr", 0)
            if atr15m == 0:
                atr15m = preco * 0.002

            analysis = [
                f"üéØ AN√ÅLISE PROFISSIONAL - {tipo_evento}",
                f"üíé {ativo} | ${preco:,.2f} | Volume: {volume:,.2f}",
                "‚îÅ" * 65
            ]

            context_lines = self._format_contexto_macro(event_data)
            if context_lines:
                analysis.extend(context_lines)

            force_index = self._calculate_force_index(delta, volume)
            volume_analysis = self._analyze_volume_profile(volume_compra, volume_venda, volume)
            microstructure = self._analyze_microstructure(delta, indice_absorcao, volume)

            if "Absor√ß√£o" in tipo_evento:
                direction = "COMPRADORA" if delta > 0 else "VENDEDORA"
                strength = self._calculate_strength(abs(delta), volume, indice_absorcao)
                analysis.extend([
                    "üìä INTERPRETA√á√ÉO T√âCNICA:",
                    f"   ‚Üí Absor√ß√£o detectada com for√ßa {direction}",
                    f"   ‚Üí √çndice de absor√ß√£o: {indice_absorcao:.2f} ({self._interpret_absorption_index(indice_absorcao)})",
                    f"   ‚Üí Force Index: {force_index:.2f}",
                    "", "‚ö° AN√ÅLISE DE FLUXO:",
                    f"   ‚Üí Delta: {delta:,.0f} ({self._interpret_delta(delta, volume)})",
                    f"   ‚Üí Ratio C/V: {volume_compra/volume_venda:.2f}" if volume_venda > 0 else "   ‚Üí Ratio C/V: ‚àû",
                    f"   ‚Üí Volume Profile: {volume_analysis}",
                    "", "üéØ FOR√áA DOMINANTE:",
                    f"   ‚Üí Press√£o {direction} com intensidade {strength}",
                    f"   ‚Üí {microstructure}",
                    "", "üìà EXPECTATIVA DE PRE√áO:",
                    self._generate_price_forecast(preco, direction, atr15m),
                    "", "üöÄ ESTRAT√âGIA RECOMENDADA:",
                    self._generate_strategy_absorption(preco, direction, atr15m)
                ])
            elif "Exaust√£o" in tipo_evento:
                exhaustion_type = self._classify_exhaustion(delta, volume)
                reversal_probability = self._calculate_reversal_probability(volume, delta)
                analysis.extend([
                    "üìä INTERPRETA√á√ÉO T√âCNICA:",
                    f"   ‚Üí Exaust√£o de volume detectada ({exhaustion_type})",
                    f"   ‚Üí Volume: {volume:,.0f} (Elevado)",
                    f"   ‚Üí Probabilidade de revers√£o: {reversal_probability:.1f}%",
                    "", "‚ö° AN√ÅLISE DE MOMENTUM:",
                    f"   ‚Üí Delta terminal: {delta:,.0f}",
                    f"   ‚Üí {volume_analysis}",
                    f"   ‚Üí Indicadores de cl√≠max: {self._detect_climax_indicators(volume, delta)}",
                    "", "üéØ FOR√áA DOMINANTE:",
                    "   ‚Üí Enfraquecimento da tend√™ncia atual",
                    f"   ‚Üí {microstructure}",
                    "", "üìà EXPECTATIVA DE PRE√áO:",
                    "   ‚Üí Consolida√ß√£o ou revers√£o esperada",
                    f"   ‚Üí N√≠veis cr√≠ticos: {self._calculate_support_resistance(preco, atr15m)}",
                    "", "üöÄ ESTRAT√âGIA RECOMENDADA:",
                    self._generate_exhaustion_strategy(reversal_probability)
                ])
            elif "Liquidez" in tipo_evento:
                liquidity_impact = self._analyze_liquidity_impact(volume, delta)
                analysis.extend([
                    "üìä INTERPRETA√á√ÉO T√âCNICA:",
                    "   ‚Üí Fluxo significativo de liquidez detectado",
                    f"   ‚Üí Impacto no book: {liquidity_impact}",
                    f"   ‚Üí Volume de impacto: {volume:,.0f}",
                    "", "‚ö° AN√ÅLISE DE LIQUIDEZ:",
                    f"   ‚Üí {volume_analysis}",
                    "   ‚Üí Reorganiza√ß√£o dos n√≠veis de S/R em andamento",
                    "", "üéØ FOR√áA DOMINANTE:",
                    "   ‚Üí Redistribui√ß√£o de liquidez ativa",
                    f"   ‚Üí {microstructure}",
                    "", "üìà EXPECTATIVA DE PRE√áO:",
                    "   ‚Üí Volatilidade aumentada no curto prazo",
                    "   ‚Üí Novos n√≠veis de equil√≠brio em forma√ß√£o",
                    "", "üöÄ ESTRAT√âGIA RECOMENDADA:",
                    self._generate_liquidity_strategy(volume)
                ])

            if event_data.get("contexto_sma"):
                analysis.append(f"üìç CONTEXTO T√âCNICO: {event_data.get('contexto_sma')}")

            analysis.extend([
                "", "‚ö†Ô∏è  GEST√ÉO DE RISCO:",
                self._generate_risk_management(atr15m),
                "", f"üïê An√°lise gerada: {datetime.now().strftime('%H:%M:%S')}",
                "‚îÅ" * 65
            ])
            return "\n".join(analysis)
        except Exception as e:
            logging.error(f"‚ùå Erro na an√°lise h√≠brida: {e}")
            return f"Erro na an√°lise h√≠brida avan√ßada: {str(e)}"

    def _generate_price_forecast(self, preco, direction, atr):
        if direction == "COMPRADORA":
            target = preco + (1.5 * atr)
            return f"   ‚Üí Press√£o para ALTA. Alvo sugerido (1.5x ATR): ${target:,.2f}"
        else:
            target = preco - (1.5 * atr)
            return f"   ‚Üí Press√£o para BAIXA. Alvo sugerido (1.5x ATR): ${target:,.2f}"

    def _generate_strategy_absorption(self, preco, direction, atr):
        if direction == "COMPRADORA":
            stop_loss = preco - (1.0 * atr)
            return f"   ‚Üí Entrada COMPRADORA em pullbacks. Stop sugerido (1x ATR): ${stop_loss:,.2f}"
        else:
            stop_loss = preco + (1.0 * atr)
            return f"   ‚Üí Entrada VENDEDORA em bounces. Stop sugerido (1x ATR): ${stop_loss:,.2f}"

    def _generate_risk_management(self, atr):
        return f"   ‚Üí Volatilidade (ATR 15m): ${atr:,.2f}. Ajuste o tamanho da posi√ß√£o de acordo."
    
    def _calculate_support_resistance(self, preco, atr):
        support = preco - (0.5 * atr)
        resistance = preco + (0.5 * atr)
        return f"S: ${support:,.2f} | R: ${resistance:,.2f}"

    def _generate_exhaustion_strategy(self, probability):
        if probability > 70: return "   ‚Üí Preparar revers√£o. Aguardar sinal de confirma√ß√£o."
        elif probability > 50: return "   ‚Üí Reduzir posi√ß√µes na dire√ß√£o atual. Monitorar."
        else: return "   ‚Üí Poss√≠vel pausa. Manter posi√ß√µes com stop ajustado."

    def _generate_liquidity_strategy(self, volume):
        if volume > 100000:
            return "   ‚Üí Aguardar estabiliza√ß√£o. Evitar entradas imediatas."
        return "   ‚Üí Monitorar breakouts dos novos n√≠veis."
        
    def _calculate_force_index(self, delta, volume):
        if volume == 0: return 0
        return (delta / volume) * 100

    def _analyze_volume_profile(self, volume_compra, volume_venda, volume_total):
        if volume_total == 0: return "Sem volume"
        buy_percentage = (volume_compra / volume_total) * 100
        sell_percentage = (volume_venda / volume_total) * 100
        if buy_percentage > 60: return f"Domin√¢ncia compradora ({buy_percentage:.1f}%)"
        elif sell_percentage > 60: return f"Domin√¢ncia vendedora ({sell_percentage:.1f}%)"
        return f"Equilibrado (C:{buy_percentage:.1f}% V:{sell_percentage:.1f}%)"

    def _analyze_microstructure(self, delta, indice_absorcao, volume):
        if abs(delta) > volume * 0.1: return "Microestrutura direcional forte"
        elif indice_absorcao > 2: return "Absor√ß√£o significativa detectada"
        return "Microestrutura neutra"

    def _calculate_strength(self, abs_delta, volume, indice_absorcao):
        delta_ratio = abs_delta / volume if volume > 0 else 0
        if delta_ratio > 0.15 and indice_absorcao > 2: return "MUITO FORTE"
        elif delta_ratio > 0.1 or indice_absorcao > 1.5: return "FORTE"
        elif delta_ratio > 0.05: return "MODERADA"
        return "FRACA"

    def _interpret_absorption_index(self, indice):
        if indice > 3: return "Absor√ß√£o extrema"
        elif indice > 2: return "Absor√ß√£o forte"
        elif indice > 1: return "Absor√ß√£o moderada"
        return "Absor√ß√£o fraca"

    def _interpret_delta(self, delta, volume):
        if volume == 0: return "sem volume"
        ratio = abs(delta) / volume
        if ratio > 0.2: return "desequil√≠brio extremo"
        elif ratio > 0.1: return "desequil√≠brio significativo"
        elif ratio > 0.05: return "desequil√≠brio moderado"
        return "relativamente equilibrado"

    def _classify_exhaustion(self, delta, volume):
        if volume > 50000:
            if abs(delta) < volume * 0.05: return "Exaust√£o por distribui√ß√£o"
            else: return "Exaust√£o clim√°tica"
        return "Exaust√£o por baixo interesse"

    def _calculate_reversal_probability(self, volume, delta):
        volume_factor = min(volume / 10000, 5)
        delta_factor = abs(delta) / volume if volume > 0 else 0
        probability = (volume_factor * 10) + (delta_factor * 30) + 20
        return min(probability, 95)

    def _detect_climax_indicators(self, volume, delta):
        indicators = []
        if volume > 100000: indicators.append("Volume extremo")
        if abs(delta) > volume * 0.2: indicators.append("Delta extremo")
        if not indicators: indicators.append("Volume/Delta elevado")
        return ", ".join(indicators)
    
    def _analyze_liquidity_impact(self, volume, delta):
        impact_ratio = abs(delta) / volume if volume > 0 else 0
        if impact_ratio > 0.2: return "Alto impacto"
        elif impact_ratio > 0.1: return "Impacto moderado"
        return "Baixo impacto"

    def close(self):
        pass

    def __del__(self):
        self.close()