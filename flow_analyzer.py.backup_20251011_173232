# flow_analyzer.py v2.1.1 - MELHORADO COM VALIDA√á√ÉO DE VOLUMES
"""
Flow Analyzer com valida√ß√£o de consist√™ncia de volumes.

üîπ MELHORIAS v2.1.1:
  ‚úÖ Adiciona valida√ß√£o volume_total = buy + sell
  ‚úÖ Usa Decimal para c√°lculos cr√≠ticos (evita erro 0.01)
  ‚úÖ Logs detalhados de discrep√¢ncias
  ‚úÖ Todas as corre√ß√µes da v2.1.0 mantidas
"""

import logging
from threading import Lock
from collections import deque
from typing import List, Dict, Any, Optional, Tuple
from decimal import Decimal, ROUND_HALF_UP
import time

import config

from time_manager import TimeManager
from liquidity_heatmap import LiquidityHeatmap

try:
    from config import (
        NET_FLOW_WINDOWS_MIN,
        AGGRESSIVE_ORDER_SIZE_THRESHOLD,
        ABSORCAO_DELTA_EPS,
        ABSORCAO_GUARD_MODE,
    )
except Exception:
    NET_FLOW_WINDOWS_MIN = [1, 5, 15]
    AGGRESSIVE_ORDER_SIZE_THRESHOLD = 0.0
    ABSORCAO_DELTA_EPS = 1.0
    ABSORCAO_GUARD_MODE = "warn"


class FlowAnalyzerError(Exception):
    """Levantada quando FlowAnalyzer encontra erro cr√≠tico."""
    pass


def _guard_absorcao(delta: float, rotulo: str, eps: float, mode: str = "warn"):
    """Valida√ß√£o de consist√™ncia para absor√ß√£o."""
    try:
        mode = (mode or "warn").strip().lower()
    except Exception:
        mode = "warn"

    if mode == "off":
        return

    mismatch = (delta > eps and rotulo != "Absor√ß√£o de Compra") or \
               (delta < -eps and rotulo != "Absor√ß√£o de Venda")
    
    if mismatch:
        msg = f"[ABSORCAO_GUARD] delta={delta:.4f} eps={eps} rotulo='{rotulo}' (modo={mode})"
        if mode == "raise":
            raise AssertionError(msg)
        logging.warning(msg)


def _decimal_round(value: float, decimals: int = 8) -> float:
    """Arredonda usando Decimal para evitar erros de float."""
    try:
        d = Decimal(str(value))
        quantize_str = '0.' + '0' * decimals
        return float(d.quantize(Decimal(quantize_str), rounding=ROUND_HALF_UP))
    except Exception:
        return round(value, decimals)


class FlowAnalyzer:
    """
    Analisador de fluxo com valida√ß√£o robusta de volumes.
    
    üîπ MELHORIAS v2.1.1:
      - Valida√ß√£o autom√°tica de consist√™ncia
      - Arredondamento decimal preciso
      - Logs de discrep√¢ncias
    """

    def __init__(self, time_manager: Optional[TimeManager] = None):
        self.time_manager = time_manager or TimeManager()

        self.cvd = 0.0
        self.whale_threshold = float(getattr(config, "WHALE_TRADE_THRESHOLD", 5.0))
        self.whale_buy_volume = 0.0
        self.whale_sell_volume = 0.0
        self.whale_delta = 0.0

        self.last_reset_ms = self.time_manager.now_ms()
        self.reset_interval_ms = int(
            getattr(config, "CVD_RESET_INTERVAL_HOURS", 24) * 3600 * 1000
        )

        self._lock = Lock()

        self.recent_trades = deque(maxlen=500)
        self.bursts = {"count": 0, "max_burst_volume": 0.0}
        self._in_burst = False
        self._last_burst_end_ms = 0

        self.burst_window_ms = int(getattr(config, "BURST_WINDOW_MS", 200))
        self.burst_cooldown_ms = int(getattr(config, "BURST_COOLDOWN_MS", 200))
        self.burst_volume_threshold = float(
            getattr(config, "BURST_VOLUME_THRESHOLD", self.whale_threshold)
        )

        order_buckets = getattr(config, "ORDER_SIZE_BUCKETS", {
            "retail": (0, 0.5),
            "mid": (0.5, 2.0),
            "whale": (2.0, 9999.0)
        })
        self.sector_flow = {
            name: {"buy": 0.0, "sell": 0.0, "delta": 0.0}
            for name in order_buckets
        }
        self._order_buckets = order_buckets

        lhm_window_size = int(getattr(config, "LHM_WINDOW_SIZE", 2000))
        lhm_cluster_threshold_pct = float(getattr(config, "LHM_CLUSTER_THRESHOLD_PCT", 0.003))
        lhm_min_trades_per_cluster = int(getattr(config, "LHM_MIN_TRADES_PER_CLUSTER", 5))
        lhm_update_interval_ms = int(getattr(config, "LHM_UPDATE_INTERVAL_MS", 100))

        self.liquidity_heatmap = LiquidityHeatmap(
            window_size=lhm_window_size,
            cluster_threshold_pct=lhm_cluster_threshold_pct,
            min_trades_per_cluster=lhm_min_trades_per_cluster,
            update_interval_ms=lhm_update_interval_ms
        )

        self.net_flow_windows_min: List[int] = list(NET_FLOW_WINDOWS_MIN)
        self.flow_trades: deque = deque()

        self.absorcao_eps: float = float(getattr(config, "ABSORCAO_DELTA_EPS", ABSORCAO_DELTA_EPS))
        try:
            self.absorcao_guard_mode: str = str(
                getattr(config, "ABSORCAO_GUARD_MODE", ABSORCAO_GUARD_MODE)
            ).lower()
        except Exception:
            self.absorcao_guard_mode = "warn"
        
        self._total_trades_processed = 0
        self._invalid_trades = 0
        self._lock_contentions = 0
        self._last_price: Optional[float] = None
        
        # Contadores de corre√ß√£o
        self._whale_delta_corrections = 0
        self._is_buyer_maker_conversions = 0
        self._volume_discrepancies = 0  # üÜï

        logging.info(
            "‚úÖ FlowAnalyzer v2.1.1 inicializado | "
            "Whale threshold: %.2f BTC | Net flow windows: %s min",
            self.whale_threshold,
            self.net_flow_windows_min,
        )

    @staticmethod
    def map_absorcao_label(aggression_side: str) -> str:
        """Mapeia lado de agress√£o para r√≥tulo."""
        side = (aggression_side or "").strip().lower()
        if side == "buy":
            return "Absor√ß√£o de Compra"
        if side == "sell":
            return "Absor√ß√£o de Venda"
        return "Absor√ß√£o"

    @staticmethod
    def classificar_absorcao_por_delta(delta: float, eps: float = 1.0) -> str:
        """Classificador de absor√ß√£o por sinal do delta."""
        try:
            d = float(delta)
        except Exception:
            return "Neutra"
        
        if d > eps:
            return "Absor√ß√£o de Compra"
        if d < -eps:
            return "Absor√ß√£o de Venda"
        return "Neutra"

    def _reset_metrics(self):
        """Reseta todas as m√©tricas acumuladas."""
        try:
            self.cvd = 0.0
            self.whale_buy_volume = 0.0
            self.whale_sell_volume = 0.0
            self.whale_delta = 0.0
            self.recent_trades.clear()
            self.bursts = {"count": 0, "max_burst_volume": 0.0}
            self._in_burst = False
            self._last_burst_end_ms = 0
            self.sector_flow = {
                name: {"buy": 0.0, "sell": 0.0, "delta": 0.0}
                for name in self._order_buckets
            }
            self.flow_trades.clear()
            self._last_price = None
            self.last_reset_ms = self.time_manager.now_ms()
            logging.info("üîÑ FlowAnalyzer metrics resetados.")
        except Exception as e:
            logging.error(f"Erro ao resetar m√©tricas: {e}")

    def _check_reset(self):
        """Verifica se deve resetar m√©tricas."""
        try:
            now_ms = self.time_manager.now_ms()
            if now_ms - self.last_reset_ms > self.reset_interval_ms:
                with self._lock:
                    self._reset_metrics()
        except Exception as e:
            logging.error(f"Erro ao verificar reset: {e}")

    def _prune_recent(self, now_ms: int):
        """Remove trades antigos fora da janela de bursts."""
        try:
            while self.recent_trades and \
                  (now_ms - self.recent_trades[0][0] > self.burst_window_ms):
                self.recent_trades.popleft()
        except Exception as e:
            logging.error(f"Erro ao podar recent_trades: {e}")
            self.recent_trades.clear()

    def _prune_flow_history(self, now_ms: int):
        """Remove trades antigos do hist√≥rico de flow."""
        try:
            if not self.net_flow_windows_min:
                return
            max_window = max(self.net_flow_windows_min)
            cutoff_ms = now_ms - max_window * 60 * 1000
            while self.flow_trades and self.flow_trades[0]['ts'] < cutoff_ms:
                self.flow_trades.popleft()
        except Exception as e:
            logging.debug(f"Erro ao podar flow_trades: {e}")

    def _update_bursts(self, ts_ms: int, qty: float):
        """Detecta bursts de volume."""
        try:
            self.recent_trades.append((ts_ms, qty))
            self._prune_recent(ts_ms)
            burst_volume = sum(q for _, q in self.recent_trades)
            threshold = self.burst_volume_threshold

            if not self._in_burst:
                if burst_volume >= threshold and \
                   (ts_ms - self._last_burst_end_ms) >= self.burst_cooldown_ms:
                    self.bursts["count"] += 1
                    self._in_burst = True
                    if burst_volume > self.bursts["max_burst_volume"]:
                        self.bursts["max_burst_volume"] = burst_volume
            else:
                if burst_volume > self.bursts["max_burst_volume"]:
                    self.bursts["max_burst_volume"] = burst_volume
                if burst_volume < threshold * 0.5:
                    self._in_burst = False
                    self._last_burst_end_ms = ts_ms
        except Exception as e:
            logging.error(f"Erro ao atualizar bursts: {e}")
            self._in_burst = False
            self._last_burst_end_ms = ts_ms

    def _update_sector_flow(self, qty: float, delta_btc: float):
        """Atualiza sector flow com arredondamento decimal."""
        try:
            for name, (minv, maxv) in self._order_buckets.items():
                if minv <= qty < maxv:
                    if delta_btc > 0:
                        self.sector_flow[name]["buy"] = _decimal_round(
                            self.sector_flow[name]["buy"] + qty
                        )
                    else:
                        self.sector_flow[name]["sell"] = _decimal_round(
                            self.sector_flow[name]["sell"] + qty
                        )
                    self.sector_flow[name]["delta"] = _decimal_round(
                        self.sector_flow[name]["delta"] + delta_btc
                    )
                    break
        except Exception as e:
            logging.error(f"Erro ao atualizar sector_flow: {e}")

    def process_trade(self, trade: dict):
        """Processa trade e atualiza m√©tricas."""
        try:
            self._check_reset()
            self._total_trades_processed += 1

            if not isinstance(trade, dict):
                self._invalid_trades += 1
                return
            
            if not all(k in trade for k in ("q", "T", "p")):
                self._invalid_trades += 1
                return

            try:
                qty = float(trade.get('q', 0.0))
                ts = int(trade.get('T'))
                price = float(trade.get('p', 0.0))
            except (ValueError, TypeError):
                self._invalid_trades += 1
                return

            if qty <= 0 or price <= 0 or ts <= 0:
                self._invalid_trades += 1
                return

            # Convers√£o corrigida de is_buyer_maker
            is_buyer_maker = trade.get('m', None)
            
            if isinstance(is_buyer_maker, bool):
                pass
            elif isinstance(is_buyer_maker, (int, float)):
                is_buyer_maker = bool(int(is_buyer_maker))
            elif isinstance(is_buyer_maker, str):
                is_buyer_maker = is_buyer_maker.strip().lower() in {
                    "true", "t", "1", "yes"
                }
                self._is_buyer_maker_conversions += 1
            else:
                self._invalid_trades += 1
                logging.warning(f"Tipo inv√°lido para 'm': {type(is_buyer_maker)}")
                return

            # Calcular delta com arredondamento decimal
            delta_btc = _decimal_round(-qty if is_buyer_maker else qty)
            delta_usd = _decimal_round(delta_btc * price, decimals=2)
            side = "sell" if is_buyer_maker else "buy"

            with self._lock:
                # Atualizar CVD
                self.cvd = _decimal_round(self.cvd + delta_btc)

                # Atualizar whale metrics
                if qty >= self.whale_threshold:
                    if delta_btc > 0:  # Compra
                        self.whale_buy_volume = _decimal_round(
                            self.whale_buy_volume + qty
                        )
                    else:  # Venda
                        self.whale_sell_volume = _decimal_round(
                            self.whale_sell_volume + qty
                        )
                    self.whale_delta = _decimal_round(
                        self.whale_delta + delta_btc
                    )
                    
                    # Valida√ß√£o de consist√™ncia
                    expected_delta = _decimal_round(
                        self.whale_buy_volume - self.whale_sell_volume
                    )
                    actual_delta = self.whale_delta
                    
                    if abs(expected_delta - actual_delta) > 0.001:
                        logging.error(
                            f"üî¥ INCONSIST√äNCIA: whale_delta={actual_delta:.8f}, "
                            f"mas buy-sell={expected_delta:.8f} "
                            f"(buy={self.whale_buy_volume:.8f}, sell={self.whale_sell_volume:.8f})"
                        )
                        
                        self.whale_delta = expected_delta
                        self._whale_delta_corrections += 1
                        logging.warning(f"‚úÖ Corrigido para {expected_delta:.8f}")

                self._update_bursts(ts, qty)
                self._update_sector_flow(qty, delta_btc)

                self.liquidity_heatmap.add_trade(
                    price=price,
                    volume=qty,
                    side=side,
                    timestamp_ms=ts
                )

                try:
                    sector_name: Optional[str] = None
                    for name, (minv, maxv) in self._order_buckets.items():
                        if minv <= qty < maxv:
                            sector_name = name
                            break

                    self.flow_trades.append({
                        'ts': ts,
                        'price': price,
                        'qty': qty,
                        'delta_btc': delta_btc,
                        'delta_usd': delta_usd,
                        'side': side,
                        'sector': sector_name,
                    })

                    self._prune_flow_history(ts)
                    self._last_price = price

                except Exception as e:
                    logging.debug(f"Erro ao salvar trade no hist√≥rico: {e}")

        except Exception as e:
            logging.debug(f"Erro ao processar trade: {e}")
            self._invalid_trades += 1

    def _normalize_heatmap_clusters(
        self, 
        clusters: List[Dict[str, Any]], 
        now_ms: int
    ) -> List[Dict[str, Any]]:
        """Normaliza clusters do heatmap."""
        out: List[Dict[str, Any]] = []
        
        for c in clusters or []:
            cc = dict(c)
            
            try:
                recent_keys = (
                    "recent_timestamp", "recent_ts_ms", "last_seen_ms",
                    "last_ts_ms", "max_timestamp", "last_timestamp"
                )
                recent_ts = None
                
                for k in recent_keys:
                    if k in cc and isinstance(cc[k], (int, float)):
                        recent_ts = int(cc[k])
                        break
                
                if recent_ts is not None:
                    cc["age_ms"] = self.time_manager.calc_age_ms(
                        recent_ts, 
                        reference_ts_ms=now_ms
                    )

                tv = cc.get("total_volume", None)
                bv = float(cc.get("buy_volume", 0.0) or 0.0)
                sv = float(cc.get("sell_volume", 0.0) or 0.0)
                
                if tv is None or (isinstance(tv, (int, float)) and tv <= 0):
                    recomputed = bv + sv
                    if recomputed > 0:
                        cc["total_volume"] = recomputed

                tv2 = float(cc.get("total_volume", 0.0) or 0.0)
                if tv2 > 0:
                    imb = (bv - sv) / tv2
                else:
                    imb = 0.0
                
                cc["imbalance_ratio"] = max(-1.0, min(1.0, float(imb)))

                if "high" in cc and "low" in cc:
                    try:
                        hi, lo = float(cc["high"]), float(cc["low"])
                        cc["width"] = max(0.0, hi - lo)
                    except Exception:
                        pass

                if "trades_count" in cc:
                    try:
                        cc["trades_count"] = int(cc["trades_count"])
                    except Exception:
                        pass

            except Exception as e:
                logging.warning(f"‚ö†Ô∏è Erro ao normalizar cluster: {e}")

            out.append(cc)
        
        return out

    def get_flow_metrics(
        self, 
        reference_epoch_ms: Optional[int] = None
    ) -> dict:
        """Retorna m√©tricas de fluxo com valida√ß√£o de volumes."""
        try:
            acquired = self._lock.acquire(timeout=5.0)
            
            if not acquired:
                self._lock_contentions += 1
                error_msg = f"‚ùå FlowAnalyzer lock timeout ap√≥s 5s"
                logging.error(error_msg)
                raise FlowAnalyzerError(error_msg)

            try:
                now_ms = reference_epoch_ms if reference_epoch_ms is not None \
                         else self.time_manager.now_ms()
                
                time_index = self.time_manager.build_time_index(
                    now_ms, 
                    include_local=True, 
                    timespec="milliseconds"
                )

                # Valida√ß√£o final whale delta
                expected_whale_delta = _decimal_round(
                    self.whale_buy_volume - self.whale_sell_volume
                )
                if abs(self.whale_delta - expected_whale_delta) > 0.001:
                    logging.error(
                        f"üî¥ CORRE√á√ÉO FINAL: whale_delta={self.whale_delta:.8f} "
                        f"‚Üí {expected_whale_delta:.8f}"
                    )
                    self.whale_delta = expected_whale_delta
                    self._whale_delta_corrections += 1

                metrics = {
                    "cvd": _decimal_round(self.cvd),
                    "whale_buy_volume": _decimal_round(self.whale_buy_volume),
                    "whale_sell_volume": _decimal_round(self.whale_sell_volume),
                    "whale_delta": _decimal_round(self.whale_delta),
                    "bursts": dict(self.bursts),
                    "sector_flow": {
                        k: {
                            "buy": _decimal_round(v["buy"]),
                            "sell": _decimal_round(v["sell"]),
                            "delta": _decimal_round(v["delta"])
                        }
                        for k, v in self.sector_flow.items()
                    },
                    "timestamp": time_index["timestamp_utc"],
                    "time_index": time_index,
                    "metadata": {
                        "burst_window_ms": self.burst_window_ms,
                        "burst_cooldown_ms": self.burst_cooldown_ms,
                        "in_burst": bool(self._in_burst),
                        "last_reset_ms": self.last_reset_ms,
                        "last_reset_iso_utc": self.time_manager.format_timestamp(
                            self.last_reset_ms
                        ),
                    },
                }

                # üÜï VALIDA√á√ÉO DE CONSIST√äNCIA DE VOLUMES
                for sector_name, sector_data in metrics["sector_flow"].items():
                    buy_vol = sector_data["buy"]
                    sell_vol = sector_data["sell"]
                    delta = sector_data["delta"]
                    
                    expected_delta = _decimal_round(buy_vol - sell_vol)
                    
                    if abs(delta - expected_delta) > 0.001:
                        logging.warning(
                            f"‚ö†Ô∏è DISCREP√ÇNCIA em sector_flow[{sector_name}]: "
                            f"delta={delta:.8f}, mas buy-sell={expected_delta:.8f}"
                        )
                        self._volume_discrepancies += 1

                # Order flow
                try:
                    order_flow: Dict[str, Any] = {}
                    absorcao_por_janela: Dict[int, str] = {}

                    if not self.net_flow_windows_min:
                        smallest_window = 1
                    else:
                        smallest_window = min(self.net_flow_windows_min)

                    tick_rule_sum = 0.0
                    
                    for window_min in self.net_flow_windows_min:
                        window_ms = window_min * 60 * 1000
                        start_ms = now_ms - window_ms
                        
                        relevant = [
                            t for t in self.flow_trades 
                            if t['ts'] >= start_ms
                        ]

                        total_delta_usd = sum(t['delta_usd'] for t in relevant)
                        total_delta_usd = _decimal_round(total_delta_usd, decimals=2)
                        
                        total_buy_usd = Decimal('0')
                        total_sell_usd = Decimal('0')
                        total_buy_btc = Decimal('0')  # üÜï
                        total_sell_btc = Decimal('0')  # üÜï
                        
                        for t in relevant:
                            qty_dec = Decimal(str(t['qty']))
                            price_dec = Decimal(str(t['price']))
                            
                            if t['side'] == 'buy':
                                total_buy_usd += price_dec * qty_dec
                                total_buy_btc += qty_dec
                            else:
                                total_sell_usd += price_dec * qty_dec
                                total_sell_btc += qty_dec

                        total_buy_usd = float(total_buy_usd)
                        total_sell_usd = float(total_sell_usd)
                        total_buy_btc = float(total_buy_btc)
                        total_sell_btc = float(total_sell_btc)

                        key_net = f"net_flow_{window_min}m"
                        order_flow[key_net] = _decimal_round(total_delta_usd, decimals=4)

                        rotulo = self.classificar_absorcao_por_delta(
                            total_delta_usd, 
                            eps=self.absorcao_eps
                        )
                        _guard_absorcao(
                            total_delta_usd, 
                            rotulo, 
                            self.absorcao_eps, 
                            self.absorcao_guard_mode
                        )

                        order_flow[f"absorcao_{window_min}m"] = rotulo
                        absorcao_por_janela[window_min] = rotulo

                        if window_min == smallest_window:
                            total_vol_usd = total_buy_usd + total_sell_usd
                            total_vol_btc = total_buy_btc + total_sell_btc
                            
                            # üÜï VALIDA√á√ÉO DE CONSIST√äNCIA
                            expected_delta_btc = _decimal_round(
                                total_buy_btc - total_sell_btc
                            )
                            actual_delta_btc = sum(
                                t['delta_btc'] for t in relevant
                            )
                            actual_delta_btc = _decimal_round(actual_delta_btc)
                            
                            if abs(expected_delta_btc - actual_delta_btc) > 0.01:
                                logging.warning(
                                    f"‚ö†Ô∏è DISCREP√ÇNCIA {window_min}m: "
                                    f"Œ£delta_btc={actual_delta_btc:.4f}, "
                                    f"mas buy-sell={expected_delta_btc:.4f} "
                                    f"(buy={total_buy_btc:.4f}, sell={total_sell_btc:.4f})"
                                )
                                self._volume_discrepancies += 1
                            
                            if total_vol_usd > 0:
                                flow_imbalance = total_delta_usd / total_vol_usd
                                order_flow["flow_imbalance"] = _decimal_round(
                                    flow_imbalance, decimals=4
                                )
                            else:
                                order_flow["flow_imbalance"] = 0.0

                            if total_vol_usd > 0:
                                order_flow["aggressive_buy_pct"] = _decimal_round(
                                    (total_buy_usd / total_vol_usd) * 100.0, decimals=2
                                )
                                order_flow["aggressive_sell_pct"] = _decimal_round(
                                    (total_sell_usd / total_vol_usd) * 100.0, decimals=2
                                )
                            else:
                                order_flow["aggressive_buy_pct"] = None
                                order_flow["aggressive_sell_pct"] = None

                            if total_buy_usd > 0 and total_sell_usd > 0:
                                order_flow["buy_sell_ratio"] = _decimal_round(
                                    total_buy_usd / total_sell_usd, decimals=4
                                )
                            else:
                                order_flow["buy_sell_ratio"] = None

                            order_flow["buy_volume"] = _decimal_round(total_buy_usd, decimals=2)
                            order_flow["sell_volume"] = _decimal_round(total_sell_usd, decimals=2)
                            order_flow["buy_volume_btc"] = _decimal_round(total_buy_btc, decimals=8)  # üÜï
                            order_flow["sell_volume_btc"] = _decimal_round(total_sell_btc, decimals=8)  # üÜï
                            order_flow["total_volume_btc"] = _decimal_round(total_vol_btc, decimals=8)  # üÜï

                            tick_rule_sum = 0.0
                            prev_price = None
                            
                            for t in sorted(relevant, key=lambda x: x['ts']):
                                curr_price = t['price']
                                if prev_price is not None:
                                    if curr_price > prev_price:
                                        tick_rule_sum += 1.0
                                    elif curr_price < prev_price:
                                        tick_rule_sum -= 1.0
                                prev_price = curr_price
                            
                            order_flow["tick_rule_sum"] = _decimal_round(
                                tick_rule_sum, decimals=4
                            )

                    if self.net_flow_windows_min:
                        metrics["tipo_absorcao"] = absorcao_por_janela.get(
                            smallest_window, "Neutra"
                        )
                    else:
                        metrics["tipo_absorcao"] = "Neutra"

                    # Participant analysis
                    participant_analysis: Dict[str, Any] = {}
                    
                    if self.net_flow_windows_min:
                        largest_window = max(self.net_flow_windows_min)
                        start_ms_p = now_ms - largest_window * 60 * 1000
                        all_trades = [
                            t for t in self.flow_trades 
                            if t['ts'] >= start_ms_p
                        ]
                        total_qty_all = sum(t['qty'] for t in all_trades)

                        for sector in self._order_buckets.keys():
                            sector_trades = [
                                t for t in all_trades 
                                if t.get('sector') == sector
                            ]
                            total_qty_sector = sum(t['qty'] for t in sector_trades)
                            buy_qty = sum(
                                t['qty'] for t in sector_trades 
                                if t['delta_btc'] > 0
                            )
                            sell_qty = sum(
                                t['qty'] for t in sector_trades 
                                if t['delta_btc'] < 0
                            )
                            count_trades = len(sector_trades)

                            if buy_qty > sell_qty:
                                direction = "BUY"
                            elif sell_qty > buy_qty:
                                direction = "SELL"
                            else:
                                direction = "NEUTRAL"

                            avg_order_size = _decimal_round(
                                total_qty_sector / count_trades, decimals=4
                            ) if count_trades > 0 else None
                            
                            volume_pct = _decimal_round(
                                (total_qty_sector / total_qty_all) * 100.0, decimals=2
                            ) if total_qty_all > 0 else None
                            
                            sentiment = "BULLISH" if direction == "BUY" else \
                                       ("BEARISH" if direction == "SELL" else "NEUTRAL")
                            
                            duration_seconds = largest_window * 60
                            trades_per_sec = _decimal_round(
                                count_trades / duration_seconds, decimals=4
                            ) if duration_seconds > 0 else None
                            
                            activity_level = "HIGH" if trades_per_sec and \
                                            trades_per_sec >= 1.0 else "LOW"

                            participant_analysis[sector] = {
                                "volume_pct": volume_pct,
                                "direction": direction,
                                "avg_order_size": avg_order_size,
                                "sentiment": sentiment,
                                "activity_level": activity_level,
                            }

                    metrics["order_flow"] = order_flow
                    metrics["participant_analysis"] = participant_analysis

                except Exception as e:
                    logging.error(f"Erro ao calcular order_flow: {e}", exc_info=True)
                    metrics["order_flow"] = {
                        "flow_imbalance": 0.0,
                        "tick_rule_sum": 0.0,
                        "buy_sell_ratio": None,
                    }
                    metrics["participant_analysis"] = {}

                # Heatmap
                try:
                    clusters = self.liquidity_heatmap.get_clusters(top_n=5)
                    clusters = self._normalize_heatmap_clusters(clusters, now_ms=now_ms)
                    supports, resistances = self.liquidity_heatmap.get_support_resistance()
                    
                    metrics["liquidity_heatmap"] = {
                        "clusters": clusters,
                        "supports": sorted(set(supports)),
                        "resistances": sorted(set(resistances)),
                        "clusters_count": len(clusters),
                    }
                except Exception as e:
                    logging.error(f"Erro ao obter heatmap: {e}", exc_info=True)
                    metrics["liquidity_heatmap"] = {
                        "clusters": [],
                        "supports": [],
                        "resistances": [],
                        "clusters_count": 0,
                    }

                metrics["data_quality"] = {
                    "total_trades_processed": self._total_trades_processed,
                    "invalid_trades": self._invalid_trades,
                    "valid_rate_pct": _decimal_round(
                        100 * (1 - self._invalid_trades / max(1, self._total_trades_processed)),
                        decimals=2
                    ),
                    "flow_trades_count": len(self.flow_trades),
                    "lock_contentions": self._lock_contentions,
                    "whale_delta_corrections": self._whale_delta_corrections,
                    "is_buyer_maker_conversions": self._is_buyer_maker_conversions,
                    "volume_discrepancies": self._volume_discrepancies,  # üÜï
                }

                return metrics

            finally:
                self._lock.release()

        except FlowAnalyzerError:
            raise
        except Exception as e:
            logging.error(f"Erro ao obter flow metrics: {e}", exc_info=True)
            
            now_ms = reference_epoch_ms if reference_epoch_ms is not None \
                     else self.time_manager.now_ms()
            time_index = self.time_manager.build_time_index(
                now_ms, include_local=True, timespec="milliseconds"
            )
            
            return {
                "cvd": 0.0,
                "whale_delta": 0.0,
                "order_flow": {
                    "flow_imbalance": 0.0,
                    "tick_rule_sum": 0.0,
                    "buy_sell_ratio": None,
                },
                "timestamp": time_index["timestamp_utc"],
                "data_quality": {
                    "error": str(e),
                    "is_valid": False,
                },
            }
    
    def get_stats(self) -> Dict[str, Any]:
        """Retorna estat√≠sticas de performance."""
        return {
            "total_trades_processed": self._total_trades_processed,
            "invalid_trades": self._invalid_trades,
            "valid_rate_pct": _decimal_round(
                100 * (1 - self._invalid_trades / max(1, self._total_trades_processed)),
                decimals=2
            ),
            "lock_contentions": self._lock_contentions,
            "flow_trades_count": len(self.flow_trades),
            "cvd": _decimal_round(self.cvd),
            "whale_delta": _decimal_round(self.whale_delta),
            "whale_delta_corrections": self._whale_delta_corrections,
            "is_buyer_maker_conversions": self._is_buyer_maker_conversions,
            "volume_discrepancies": self._volume_discrepancies,
        }